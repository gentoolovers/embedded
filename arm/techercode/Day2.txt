【1】CPSR(current program status register, cpsr)当前程序状态寄存器

      处理器模式位
      10000 User mode;    
      10001 FIQ mode;       
      10011 SVC mode;
      10111 Abort mode; 
      11011 Undfined mode; 
      11111 System mode;  
      10110 Monitor mode;   
      10010 IRQ;

      中断禁止位：
      I = 1: 禁止  IRQ
      F = 1: 禁止  FIQ

      状态位
      T = 0;处理器处于ARM 状态
      T = 1;处理器处于Thumb 状态

【2】条件位
	N：ALU中产生了负数的结果
      	Z：ALU中运算结果产生了0
      	C：
	1）加法时当产生了进位C位自动置1否则为0
        2）减法时当产生了借位C位自动置0否则为1
      	V：对于有符号数符号位发生溢出时自动置1

【3】CPSR中保存的永远是当前程序运行状态，当异常产生时异常模式下的SPSR对原有CPSR进行了备份，等到模式再切换回去的时候将SPSR中的值赋给CPSR实现现场的恢复

【4】Cortex体系结构下有40个32-Bits长的寄存器，Cortex-A多出3个寄存器，Monitor模式下的r13_mon,r14_mon,spsr_mon
      当前处理器的模式决定着哪组寄存器可操作 

【5】指令流水线：指令执行过程中取址、译码、执行三个阶段使用的硬件单元相互独立，所以当对PC地址中的指令进行取址时译码器可以对PC-4单元的指令进行译码，运算器可以对PC-8单元中的指令进行执行，从而形成了三级流水线结构，这种结构降低了指令执行的平均周期。

【6】不管多少级流水线PC指向的永远是当前取址的指令,当前执行的指令是PC-8地址处的指令

【7】异常源:导致ARM产生异常的事件
	FIQ、IRQ、Reset、软中断、DataAbort、PrefetchAbort、Undef

【8】当异常产生时ARM自动完成：
     拷贝CPSR到SPSR_<mode>
     设置适当的CPSR位： 
     	改变处理器状态进入ARM状态  
     	改变处理器模式进入相应的异常模式
     	设置中断禁止位禁止相应中断(如果需要)
     保存返回地址到LR_<mode>
     设置PC为相应的异常向量（跳转到异常向量表中对应的位置）

     返回时, 异常处理需要（用户自己完成）：
     从SPSR_<mode>恢复CPSR
     从LR_<mode>恢复PC

【9】7种异常源，异常发生时进入对应的异常模式
     异常源：  FIQ   IRQ   Reset/软中断   DataAbort/PrefetchAbort   Undef
     异常模式：FIQ   IRQ   Supervisor     Abort                     Undef

【10】当异常发生时，ARM内核完成保存现场后自动将PC指向异常向量中对应的位置处去执行，异常向量表中为每个异常源分配了四个字节的存储空间，这样我们可以人为的去在异常向量表对应的位置写一条跳转指令去将程序跳转到对应的异常处理程序处去执行

【11】异常指定了优先级和固定的服务顺序:
     Reset
     Data Abort
     FIQ
     IRQ
     Prefetch Abort
     SWI
     Undefined instruction

【12】FIQ的响应速度比IRQ快的原因：
     1.FIQ 向量位于异常向量表的最末，这样可以直接把FIQ的异常处理程序写在异常向量表之后，省去了程序跳转的时间
     2.FIQ 模式有5个额外的私有寄存器 (r8-r12)（中断处理必须保护其使用的非私有寄存器）
     3.FIQ的优先级高于IRQ，当两个异常同时发生时先响应FIQ

【13】
.global _start  @声明一个全局的符号_start
_start:         @汇编入口

@汇编文件中主要包括三部分内容：
@	1).指令：编译完成后作为一条指令存储在内存单元当中，CPU执行时能完成一定的操作
@	2).伪指令：在编译时替换成其他ARM能够识别的指令
@	3).伪操作：指导编译器进行编译，编译完成后不生成指令也不占用内存空间

@指令分为六类：
@	1).数据处理指令：对数据进行逻辑、数学等运算与处理
@	2).跳转指令：实现程序的跳转
@	3).Load/Store指令：CPU与内存之间进行数据的存取
@	4).状态寄存器传送指令：对状态寄存器进行读写操作
@	5).协处理器指令：对协处理器进行操作
@	6).异常中断产生指令：产生异常中断

stop:
	b stop   @死循环，防止跑飞 while(1)
.end         @汇编程序结束