.global _start  @声明一个全局的符号_start
_start:         @汇编入口

@汇编文件中主要包括三部分内容：
@	1).指令：编译完成后作为一条指令存储在内存单元当中，CPU执行时能完成一定的操作
@	2).伪指令：在编译时替换成其他ARM能够识别的指令
@	3).伪操作：指导编译器进行编译，编译完成后不生成指令也不占用内存空间

@指令分为六类：
@	1).数据处理指令：对数据进行逻辑、数学等运算与处理
@	2).跳转指令：实现程序的跳转
@	3).Load/Store指令：CPU与内存之间进行数据的存取
@	4).状态寄存器传送指令：对状态寄存器进行读写操作
@	5).协处理器指令：对协处理器进行操作
@	6).异常中断产生指令：产生异常中断



/*1.数据处理指令*/

@数据搬移指令
	@ mov r0, #0x55
	@ r0 = 0x55
	@ mov r1, r0
	@ r1 = r0
	@ mvn r2, r1
	@ r2 = ~r1

@立即数
	@ #0xff000000
	@ mov r0, #0xff00
	@ 立即数的本质是包含在指令当中的数
	@ 一个立即数是由一个八位二进制数循环右移偶数次得到的
	@ mov r0, #0xffffff00
	@ 不是立即数  编译器对指令进行了替换


@ 加法指令
	@ mov r0, #1
	@ add r1, r0, #1
	@ r1 = r0 + 1
	@ add r2, r0, r1
	@ r2 = r0 + r1

	@ 数据处理指令的语法：<操作>{<cond>}{S} Rd, Rn, Operand2
	@ <操作码><目标寄存器Rd><第一操作寄存器Rn><第二操作数Operand2>

@ 数据运算对CPSR的影响
	@数据运算指令后加后缀‘s’时才会对CPSR中的条件位产生影响，默认不会对CPSR中的条件位产生影响
	@ mov r0, #0
	@ adds r1, r0, #-1

	@ 带进位的加法指令
	@ 两个64位数相加，第一个64位数的低32位放在r0高32位放在r1,第二个64位数的低32位放在r2高32位放在r3
	@ 将最终结果的低32位放在r4  高32位放在r5
	@ mov r0, #0xfffffff0  @第一个数的低位
	@ mov r1, #1           @第一个数的高位

	@ mov r2, #3           @第二个数的低位
	@ mov r3, #1           @第二个数的高位

	@ adds r4, r0, r2
	@ adc r5, r1, r3
	@ r5 = r1 + r3 + c

@ 减法指令
	@ mov r0, #100
	@ sub r1, r0, #1
	@ r1 = r0 - 1

	@ 带借位的减法指令
	@ 两个64位数相减，第一个64位数的低32位放在r0高32位放在r1,第二个64位数的低32位放在r2高32位放在r3
	@ 将最终结果的低32位放在r4  高32位放在r5
	@ mov r0, #1  @第一个数的低位
	@ mov r1, #2  @第一个数的高位

	@ mov r2, #2  @第二个数的低位
	@ mov r3, #1  @第二个数的低位

	@ subs r4, r0, r2
	@ sbc  r5, r1, r3
	@ r5 = r1 - r3 - !c

@ 逆向减法指令
	@ mov r0, #100
	@ rsb r1, r0, #200
	@ r1 = 200 - r0

@ 乘法指令
	@ mov r0, #3
	@ mov r1, #5
	@ mul r2, r0, r1
	@ r2 = r0 * r1
	@ 乘法指令两个乘数必须都放在寄存器中

	@ mov r0, #3
	@ mov r1, #5
	@ mov r2, #5
	@ mla r3, r0, r1, r2
	@ r3 = r0 * r1 + r2

	@ '与'指令
	@ mov r0, #0xff
	@ and r1, r0, #0xf
	@ r1 = r0 & 0xf

	@ '或'指令
	@ mov r0, #0xf0
	@ mov r1, #0x0f
	@ orr r2, r0, r1
	@ r2 = r0 | r1

	@ 逻辑异或运算
	@ mov r0, #0xff
	@ mov r1, #0xff
	@ eor r2, r1, r0
	@ r2 = r1 eor r0

	@ 位清零指令
	@ mov r0, #0xff
	@ bic r1, r0, #0xf
	@ 0xf中哪一位是1对应的将r0中的哪一位清零，然后将结果放在r1中

	@ 比较指令
	@ mov r0, #1
	@ mov r1, #1
	@ cmp r0, r1
	@ 比较指令  当两个数相等时  Z位自动置1
	@ 实质是减法指令
	@ 没有目标寄存器

	@ 位测试指令
	@ tst r0, #0x1
	@ 实质是进行了与运算  常用于测试某一位是0还是1

	@ 相等测试指令
	@ teq r0, r1
	@ 实质是进行了异或运算，常用于测试两个数是否相等，两个数异或后相等为0，所以Z位置1

@ 桶形移位器
	@ mov r0, #0xff
	@ mov r1, r0, lsl #4
	@ r1 = (r0 << 4)

	@ lsl 逻辑左移  高位移出  低位补0
	@ lsr 逻辑右移  低位移出  高位补0
	@ asr 算数右移  低位移出  高位补符号位
	@ ror 循环右移  低位移出  高位补低位

/*跳转指令*/

@跳转指令
/*
loop1:
	mov r1, #1
	mov r2, #2
	mov r3, #3
	b loop2
	mov r4, #4
	mov r5, #5

loop2:
	mov r6, #6
	mov r7, #7
	b loop1
	mov r8, #8
*/
	@ 能够跳转到当前指令地址±32M字节的内存空间处的代码
	@ 一条跳转指令中给跳转的目标地址分配了24位的空间来表示跳转的目标地址
	@ ARM指令32位宽度，即指令的存储地址后两位永远是00
	@ 所以B指令中用24位的空间表示了一个26位的数(后两位默认是00)，这样跳转范围为2的26次方即

@ 带返回地址的跳转指令BL

MAIN:
	mov r1, #1
	mov r2, #2
	mov r3, #3
	bl FUNC     @跳转到子程序  将当前指令的下一条指令的地址保存到LR当中
	mov r4, #4
	mov r5, #5
	b stop

FUNC:
	mov r6, #6
	mov r7, #7
	mov pc, lr  @ 将返回地址赋值给PC  即实现了程序调用的返回

@ 作业：
@ 1.实现128位数减法
@ 2.模拟子程序跳转过程


stop:
	b stop   @死循环，防止跑飞 while(1)
.end         @汇编程序结束


