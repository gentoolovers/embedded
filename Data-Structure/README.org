* 第一天<2016-07-21 Thu>
** 数据结构的概念
+ 数据结构 :指数据之间的相互关系,包含下面三方面的内容
+ 逻辑结构 :表示数据运算之间的抽象关系(如邻接关系,从属关系),按每个元素可能具有的直接前趋数和直接后继数将逻辑
结构分为"线性结构"和非线性结构两大类.
+ 存储结构 :逻辑结构在计算机之间的具体实现方法,分为顺序存储方法,链接存储方法,索引存储方法,散列存储方法.
+ 数据运算 :对数据进行的操作,如插入,删除,查找,排序.
** 代码练习
*** 线性表
**** 头文件
#+BEGIN_SRC C :main no 
  #ifndef  _SEQLIST_H
  #define  _SEQLIST_H
  #define N 50
  #define SIZE 100
  typedef Book datatype;
  typedef struct book {
    int no;
    char name[N];

  }Book;

  typedef struct {

    datatype data[SIZE];
    int last;
  }SeqList;
  SeqList* SeqList_Create();
  int SeqList_Empty(SeqList *L);
  int SeqList_Locate(SeqList *L,datatype value);
  int SeqList_Insert(SeqList *L,datatype value,int Pos);
  int SeqList_DeLete(SeqList *L,int Pos);
  int SeqList_Show(SqList *L);
  #endif
#+END_SRC
**** 源代码文件
#+BEGIN_SRC C :main no 
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "SeqList.h"
  SeqList* SeqList_Create()
  {

    SeqList* L=NULL;
    if((L=(SeqList*)malloc(sizeof(SeqList))) == NULL)
      {

        printf("malloc failed\n");
        return NULL;
      }
    L->last = -1;
    return L;
  }
  /*
    如果线性表是空的返回 0,如果不是空的返回线性表的长度
   ,*/
  int SeqList_Empty(SeqList *L)
  {

    if(L->last == -1)
      {

        return 0; 
      }
    return L->last+1;
  }
  /*
    假如有这个元素返回该元素的下标,没有返回-1;
   ,*/
  int SeqList_Locate(SeqList *L,datatype value)
  {
    int i=0;
    for(i=0;i<=L->last,i++)
      {
        if(memcmp(&L->data[i],&value,sizeof(Book)))
          {
            return i;
          }
      }
    return -1;

  }
  int SeqList_Insert(SeqList *L,datatype value,int Pos)
  {
    int ret=(0<=Pos)&&((L->last +1)<sizeof(L));
      if(ret && (Pos>=L->last+1))
        {
          Pos=L->last+1;

        }
      for(i=L->last;i>=Pos;i++)
      {
        L->data[i+1]=L->data[i];

      }
      L->data[Pos]=value;
      L->last++;
      return ret;
  }
  int SeqList_DeLete(SeqList *L,int Pos)
  {

    int ret=(0<=Pos)&&(Pos<=L->last);
    int i=0;

      if(ret)
        {
           for(i=Pos;i<=L->last;i++)
              {

                 L->data[i]=L->data[i+1];
              }
               L->last--; 
        }
    return ret;
  }
  int SeqList_Show(SqList *L)
  {
    int i=0;
    for(i=0;i<=L->last;i++)
      {

        printf("book number is %d\nbook name is %s",L->data[i].no,L->data[i].name);
      }
    return 0;

  }


#+END_SRC
**** main 函数
#+BEGIN_SRC C :main no :
  #include <stdio.h>
  int main(int argc,const char* argv[])
  {

    return 0;
  }
#+END_SRC
**** Makefile
#+BEGIN_SRC makefile :
  OBJS=SeqList.o main.o
  cc=gcc
  CFLAGS= -g -Wall
  SeqList:$(OBJS)
      $(cc) $(CFLAGS)  -o  $@ $^
  SeqList.o:SeqList.c SeqList.h
      $(cc) $(CFLAGS) -c $@ $<
  main.o:main.c SeqList.h
      $(cc) $(CFLAGS) -c $@ $<
#+END_SRC
*** 单链表
**** 头文件
#+BEGIN_SRC C :main no
  typedef void LinkList;
  typedef int datatype;
 
  LinkList* LinkList_Create();

  int LinkList_Insert(LinkList* list,datatype value,int pos);

  LinkList* LinkList_Delete(LinkList* list,int pos);

  void LinkList_Show(LinkList *list);

  int LinkList_Sort(LinkList* list);

  int LinkList_Reverse(LinkList* list);
#+END_SRC
**** 源代码文件
#+BEGIN_SRC C :main no
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "LinkList.h"

  typedef struct node {
    int data;
    struct node *next;
  }TLinkList;

  /*
    创建链表的过程:从堆空间上申请表头节点并初始化,表头节点有一个数据域和一个指针域.  
   ,*/
  LinkList* LinkList_Create()
  {
    TLinkList* ret=NULL;
    ret=(TLinkList*)malloc(sizeof(TLinkList));
    if(ret != NULL)
      {

        ret->data=0;
        ret->next=NULL;
      }else
      {

        printf("malloc failed");
      }
    return ret;

  }
  /*
    插入的节点空间从堆空间上申请
    然后将一个 current 指针指向表头,然后将 current 指针移动 pos-1 个位置,开始插入
    第一步 :将插入元素的 next 指针指向 current(此时 current pos-1 的位置)的 next
    第二步 :将插入元素的数据域(即 node->data)赋值为要插入的值(value)
    第三步 :然元素进入链表,即将当前位置(pos -1 )的 next 指向我们要插入的元素
    第四步  :链表的长度加 1  

   ,*/
  int LinkList_Insert(LinkList* list,datatype value,int pos)
  {
    TLinkList* TList=(TLinkList*)list;
    int ret=(TList != NULL)&&(pos>=0)&&(pos<=TList->data);
    if(ret)
      {

        TLinkList* node=(TLinkList*)malloc(sizeof(TLinkList));
        TLinkList* current=TList;
        int i=0;
        if(pos>TList->data)
          {

            pos=TList->data;
          }
        for(i=0;(i<pos)&&(current->next !=NULL);i++)
          {

            current=current->next;
          }
        node->next=current->next;
        node->data=value;
        current->next = node;
        TList->data++;  

      }

    return ret;
  }

  /*
  第一步:合法性检测,传入的链表不能为空,删除的位置必须大于零并且小于链表的长度.

  第二步:把表头赋值给一个 current 指针,让 current 指针移动 pos 减一个位置,即移动到我们要删除的上一个元素的位置

  第三步:我们把 current 的 next,即我们要删除的元素赋值给一个 ret 指针.这样做的目的有两个,(1)ret 保存了要删除的元素,所以可以把 ret 作为返回值;(2)我们需要用到 ret 的 next,即 ret 的下一个元素.

  第四步:让链表的链跳过我们要删除的元素,current=ret->next
  第五步:链表的长度减 1

   ,*/
  LinkList* LinkList_Delete(LinkList* list,int pos)
  {
    TLinkList* TList=(TLinkList*)list;
    TLinkList* ret=NULL;
    if((TList != NULL)&&( (pos>=0)&& (pos<TList->data)))
      {

        int i=0;
        TLinkList* current=TList;
        for(i=0;i<pos;i++)
          {
            current=current->next;

          }
        ret=current->next;
        current=ret->next;
        TList->data--;

      }
    return ret;

  }
  /*
  从一个元素开始打印,用 next 指针访问下一个元素,只要下一个元素不为空,就证明还没到链表的末尾 
   ,*/
  void LinkList_Show(LinkList *list){
    TLinkList* TList=(TLinkList*)list;
    while (TList != NULL && TList->next != NULL)
      {

        printf("%d",TList->next->data);
        TList=TList->next;
      }
    puts(" ");
  }
  /*
  插入排序法给链表排序:
  + 使用一个 current 指针指向链表的第一个元素,把原来的链表置空,只要 current 的 next 不为空,就证明还没到链表末尾
  + 因为 current 指针要移动,所以用一个 save 指针保存 current 指针,然后 current 指向下一个元素
  + 然后我们还需要一个 orderlist 指针来遍历有序的链表,找到插入的位置,指针的起始位置为表头
  + 当 save 里的 data 小于 orderlist 里的某个数据或者是到达了 orderlist 链表的末尾时开始插入
  + 插入的过程其实就是在 orderlist 链表里插入一个新元素:为保证 orderlist 链表不断首先把要插入元素的 next 指针指向 orderlist 的 next,然后在把 orderlist 的 next 指向要差入的元素.


   ,*/
  int  LinkList_Sort(LinkList *list) {
    TLinkList* TList=(TLinkList*)list;
    TLinkList *current=TList->next,*save,*orderlist;
    TList->next=NULL;
    while(current != NULL)
      {
        save=current;
        current=current->next;
        orderlist=TList;
        while (orderlist->next !=NULL && orderlist->next->data <save->data)
          {

            orderlist=orderlist->next;
          }
        save->next =orderlist->next;
        orderlist->next =save;
      }
    return 0;
 
  }
  /*
    原理和 LinkList_Sort 一样,只是不需要比较,直接在头部插入即可.
   ,*/
  int LinkList_Reverse(LinkList* list) {
    TLinkList* TList=(TLinkList*)list;
    TLinkList* current=TList->next,*save;
    TList->next=NULL;
    while(current !=NULL)
      {
        save=current;
        current=current->next;
        save->next=TList->next;
        TList->next=save;
      }
    return 0;
  }


#+END_SRC

**** 主函数
#+BEGIN_SRC  C :main no
  #include <stdio.h>
  #include "LinkList.h"
  int main()
  {

    LinkList * H = NULL;
    H = LinkList_Create();
    int i = 0;
    for(i = 0; i < 5;i++)
      LinkList_Insert(H,i,0);


    LinkList_Show(H);
    return 0;
  }

#+END_SRC
**** Makefile
#+BEGIN_SRC makefile 
  OBJS=LinkList.o main.o
  CFLAGS=-g -Wall
  cc=gcc
  LinkList:$(OBJS)
      $(cc) $(CFLAGS) -o $@ $^
  SeqList.o:SeqList.c
      $(cc) $(CFLAGS) -o $@ $<
  main.o:main.c
      $(cc) $(CFLAGS) -o $@ $<
#+END_SRC

*** 单项循环链表
**** 头文件
#+BEGIN_SRC C :main no
  #ifndef _CIRCLELIST_H
  #define _CIRCLELIST_H
  typedef void CircleList;
  typedef struct _tag_CircleListNode CircleListNode;
  struct _tag_CircleListNode
  {
    CircleListNode* next;
  };
   CircleList* CircleList_Create();

  void CircleList_Destroy(CircleList* list);

  void CircleList_Clear(CircleList* list);

  int CircleList_Length(CircleList* list);

  int CircleList_Insert(CircleList* list, CircleListNode* node, int pos);

  CircleListNode* CircleList_Get(CircleList* list, int pos);

  CircleListNode* CircleList_Delete(CircleList* list, int pos);

  CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node);

  CircleListNode* CircleList_Reset(CircleList* list);

  CircleListNode* CircleList_Current(CircleList* list);

  CircleListNode* CircleList_Next(CircleList* list);


  #endif

#+END_SRC
**** 源代码文件
#+BEGIN_SRC C :main no
  #include <stdio.h>
  #include <stdlib.h>
  #include "CircleList.h"

  typedef struct CircleList
  {
    CircleListNode header;
      CircleListNode* slider;
      int length;
  }TCircleList;

  CircleList* CircleList_Create()
  {
      TCircleList* ret=(TCircleList*)malloc(sizeof(TCircleList));
      if(ret)
      {

          ret->header.next=NULL;
          ret->slider=NULL;
          ret->length=0;
      }else
      {

          printf("malloc CircleList failed");
          return NULL;
      }
      return ret;

  }

  void CircleList_Destroy(CircleList* list)
  {

      free(list);
      list=NULL;
  }

  void CircleList_Clear(CircleList* list)
  {

      TCircleList* CList=(TCircleList*)list;
      if(CList != NULL)
      {

          CList->header.next=NULL;
          CList->slider=NULL;
          CList->length=0;
      }
  }

  int CircleList_Length(CircleList* list)
  {
      TCircleList* CList=(TCircleList*)list;
      int ret=-1;
      if(CList !=NULL)
      {
          ret=CList->length;

      }
      return ret;

  }

  int CircleList_Insert(CircleList* list, CircleListNode* node, int pos)
  {

      TCircleList* CList=(TCircleList*)list;
      int ret=(CList != NULL) && (node != NULL) && (pos >=0);
      int i=0;
      if(ret)
      {
          CircleListNode* current=(CircleListNode*)CList;
          for(i=0;(i<pos) && (current->next !=NULL);i++)
          {

              current=current->next;
          }
          node->next=current->next;
          current->next=node;
          if(0==CList->length)
          {

              CList->slider=node;
          }
          CList->length++;
          if(current ==(CircleListNode*)CList)
          {

              CircleListNode* last=CircleList_Get(CList,CList->length-1);
              last->next=current->next;
          }

      }
      return ret;
  }

  CircleListNode* CircleList_Get(CircleList* list, int pos)
  {

      TCircleList* CList=(TCircleList*)list;
      CircleListNode* ret=NULL;
      int i=0;
      if((CList != NULL) && (0<=pos)&& (CList->length>0))
      {
          CircleListNode* current=(CircleListNode*)CList;
          for(i=0;i<pos;i++)
          {
              current=current->next;

          }
          ret=current->next;

      }
      return ret;
  }
  /*
  删除第一个元素时,出了需要让链表的链跳过要删除的元素之外,还需要让最后一个元素的next指向第一个元素.
  删除slider指向的元素时,需要把游标指向下一个元素.
  删除整个链表的最后一个元素时,需要把游标指向空,表头的next也指向空.

   ,*/
  CircleListNode* CircleList_Delete(CircleList* list, int pos)
  {

      TCircleList* CList=(TCircleList*)list;
      CircleListNode* ret=NULL;
      int i=0;
      if((CList != NULL) && (0<=pos) &&(CList->length >0))
      {
          CircleListNode* current=(CircleListNode*)CList;
          CircleListNode* last=NULL;
          for(i=0;i<pos;i++)
          {

              current=current->next;
          }
          if(current ==(CircleListNode*)CList)
          {
              last=CircleList_Get(CList,CList->length-1);

          }
          ret=current->next;
          current->next=ret->next;
          CList->length--;

          if(last != NULL)
          {

              CList->header.next=ret->next;
              last->next=ret->next;
          }
          if(CList->slider ==ret)
          {

              CList->slider=ret->next;
          }
          if(0==CList->length)
          {

              CList->header.next=NULL;
              CList->slider=NULL;
          }

      }
      return ret;
  }

  CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node)
  {

      TCircleList* CList=(TCircleList*)list;
      CircleListNode* ret=NULL;
      int i=0;
      if((CList != NULL)&& (node != NULL))
      {
          CircleListNode* current=(CircleListNode*)CList;
          for(i=0;i<CList->length;i++)
          {

              if(current->next == node)
              {

                  ret=current->next;
                  break;
              }
              current=current->next;
          }
          if(ret)
          {
              CircleList_Delete(CList,i);
          }

      }
      return ret;
  }

  CircleListNode* CircleList_Reset(CircleList* list)
  {
      TCircleList* CList=(TCircleList*)list;
      CircleListNode* ret=NULL;
      if(CList !=NULL)
      {

          CList->slider=CList->header.next;
          ret=CList->slider;
      }
      return ret;


  }

  CircleListNode* CircleList_Current(CircleList* list)
  {

      TCircleList* CList=(TCircleList*)list;
      CircleListNode* ret=NULL;
      if(CList != NULL)
      {

          ret=CList->slider;

      }
      return ret;
  }

  CircleListNode* CircleList_Next(CircleList* list)
  {

      TCircleList* CList=(TCircleList*)list;
      CircleListNode* ret=NULL;
      if((CList != NULL)&& (CList->slider !=NULL))
      {
          CList->slider=CList->slider->next;
          ret=CList->slider;
      }
      return ret;
  }




  int CircleList_GetPos(CircleList* list,CircleListNode* node)
  {
      TCircleList* CList=(TCircleList*)list;
      int i=0;
      if((CList != NULL))
      {

          CircleListNode* current=(CircleListNode*)CList;
          for(i=0;i<CList->length;i++)
          {

              if(current->next=node)
              {

                  return i;
              }
              current=current->next;
          }

      }
      return -1;

  }
#+END_SRC
**** 主函数
#+BEGIN_SRC C :main no
  #include <stdio.h>
  #include <stdlib.h>
  #include "CircleList.h"

  struct Value
  {
      CircleListNode header;
      int v;
  };

  void CircleList_joseph(CircleList* list,int start,int n)
  {

      if(list !=NULL)
      {
          int i=0;
          CircleList_Reset(list);

          for(i=0;i<start;i++)
          {
              CircleList_Next(list);

          }

          while(0<CircleList_Length(list))
          {
              int j=0;
              struct Value* show = (struct Value*)CircleList_DeleteNode(list,  CircleList_Current(list));
              printf("%d\n", show->v);

              for(j=0;(j<n) &&( CircleList_Current(list) !=NULL);j++)
              {

                  CircleList_Next(list);
              }

          }

      }
  }

  int main(int argc, char *argv[])
  {
      CircleList* list = CircleList_Create();

      struct Value v1;
      struct Value v2;
      struct Value v3;
      struct Value v4;
      struct Value v5;
      struct Value v6;
      struct Value v7;
      struct Value v8;

      int i = 0;

      v1.v = 1;
      v2.v = 2;
      v3.v = 3;
      v4.v = 4;
      v5.v = 5;
      v6.v = 6;
      v7.v = 7;
      v8.v = 8;

      CircleList_Insert(list, (CircleListNode*)&v1, 0);
      CircleList_Insert(list, (CircleListNode*)&v2, 0);
      CircleList_Insert(list, (CircleListNode*)&v3, 0);
      CircleList_Insert(list, (CircleListNode*)&v4, 0);
      CircleList_Insert(list, (CircleListNode*)&v5, 0);
      CircleList_Insert(list, (CircleListNode*)&v6, 0);
      CircleList_Insert(list, (CircleListNode*)&v7, 0);
      CircleList_Insert(list, (CircleListNode*)&v8, 0);

      for(i=0; i<CircleList_Length(list); i++)
      {
          struct Value* pv = (struct Value*)CircleList_Get(list, i);

          printf("%d\n", pv->v);
      }
      puts(" ");
      CircleList_joseph(list,0,2);

      printf("\n");

      CircleList_Destroy(list);

      return 0;
  }

#+END_SRC
*** 双向链表
**** 头文件
#+BEGIN_SRC C 
  #ifndef _DLINKLIST_H_
  #define _DLINKLIST_H_
  typedef void DLinkList;
  typedef struct _tag_DLinkListNode DLinkListNode;
  struct _tag_DLinkListNode
  {
    DLinkListNode *pre;
    DLinkListNode *next;
  };

  DLinkList* DLinkList_Create();

  void DLinkList_Destroy(DLinkList* list);

  void DLinkList_Clear(DLinkList* list);

  int DLinkList_Length(DLinkList* list);

  int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos);

  DLinkListNode* DLinkList_Get(DLinkList* list, int pos);

  DLinkListNode* DLinkList_Delete(DLinkList* list, int pos);

  DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node);

  DLinkListNode* DLinkList_Reset(DLinkList* list);

  DLinkListNode* DLinkList_Current(DLinkList* list);

  DLinkListNode* DLinkList_Next(DLinkList* list);

  DLinkListNode* DLinkList_Pre(DLinkList* list);


  #endif
#+END_SRC
**** 源代码文件
#+BEGIN_SRC C 
  #include <stdio.h>
  #include <stdlib.h>
  #include "DLinkList.h"
  /*
   定义表头,包含数据域,和指针域;
    ,*/
   typedef struct _tag_DLinkList
   {
     DLinkListNode header;
     DLinkListNode* slider;
     int length;
   }TDLinkList;

   /*
   创建空双向循环链表: 从堆里申请空间,申请成功后初始化,表头的前指针(pre)和后指针(next)都指向空,游标 slider 也指向空.因为表头的数据域存放长度,把 DLinkList 定义为 void 比较安全. 

    ,*/
   DLinkList* DLinkList_Create()
   {

     TDLinkList* ret=(TDLinkList*)malloc(sizeof(TDLinkList));
     if(ret !=NULL)
       {
         ret->length=0;
         ret->header.next=NULL;
         ret->header.pre=NULL;
         ret->slider=NULL;

         return ret;
       }else
       {

         printf("malloc DLinkList failed");
         return NULL;
       }

   }

   void DLinkList_Destroy(DLinkList* list)
   {

     free(list);
   }

   void DLinkList_Clear(DLinkList* list)
   {
     TDLinkList* TDList=(TDLinkList*)list;
     if(TDList != NULL)
       {

         TDList->length=0;
         TDList->header.next=NULL;
         TDList->header.pre=NULL;
         TDList->slider=NULL;
       }

   }

   int DLinkList_Length(DLinkList* list)
   {
     TDLinkList* TDList=(TDLinkList*)list;
     int ret= -1;
     if(TDList != NULL)
       {
         ret=TDList->length;
 
       }
     return ret;
   }


   /*
   注意双向链的第一个节点的 pre 指向空,尾节点的 next 指向空,空节点没有 next 和 pre  
   首先是一些合法性检测,然后用 current 移动到要插入位置的前一个位置,然后有 Next 指针指向 current 的下一个位置,因为前指针的链接需要用到这个位置.
   开始插入:因为是双向,只要不是节点一头的两条链都断,链表就不会段.但最好先链接好一个方向再断另一个方向.
   + 首先 current 的 next 指向要插入的元素
   + 其次 node 的 next 指向 Next.这样就完成了一个方向
   + 插前指针需要判断一下 Next 是否为空,为空则没有 pre 指针,假如不为空,则 Next 的 pre 指向 node
   + node 的 pre 指向 current
   + 链表长度为零的时候,slider 指向插入的元素
   + 假如 current 指向的是表头则 node 的 pre 指向空



    ,*/
   int DLinkList_Insert(DLinkList* list,DLinkListNode* node,int pos)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     int ret=(TDList !=NULL) && (node != NULL) && (pos>=0);
     int i=0;
     if(ret)
       {

         DLinkListNode* current=(DLinkListNode*)TDList;
         DLinkListNode* Next=NULL;
         for(i=0;(i<pos) && (current->next !=NULL);i++)
           {

             current=current->next;
           }
         Next=current->next;

         current->next=node;
         node->next=Next;
         if(Next != NULL)
           {

             Next->pre=node;
           }

         node->pre=current;

         if(TDList->length == 0)
           {

             TDList->slider = node;
           }
 
         if(current == (DLinkListNode*)TDList)
           {

             node->pre= NULL;
           }
         TDList->length++;

       }
     return ret;
   }

   DLinkListNode* DLinkList_Get(DLinkList* list,int pos)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret=NULL;
     int i=0;
     if((TDList != NULL) && (0 <= pos) && (pos<TDList->length))
       {

         DLinkListNode* current=(DLinkListNode*)TDList;
         for(i=0;i<pos;i++)
           {

             current=current->next;
           }
         ret=current->next;
       }
     return ret;
   }
   /*
     +   删除头节点,下一个元素的 pre 指向空
     +   删除尾节点,Next(即 NULL)没有 pre
     +   删除游标 slider 所在的节点时,slider 指向下一个元素
    ,*/
   DLinkListNode* DLinkList_Delete(DLinkList* list,int pos)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret=NULL;
     int i=0;
     if((TDList != NULL) && (0<=pos)&& (pos>TDList->length))
       {

         DLinkListNode* current=(DLinkListNode*)TDList;
         DLinkListNode* Next=NULL;
         for(i=0;i<pos;i++)
           {

             current=current->next;
           }

         ret=current->next;
         Next=ret->next;

         current->next=Next;
         if(Next != NULL)
           {

             Next->pre=current;
             if(current ==(DLinkListNode*)TDList)
               {

                 Next->pre=NULL;
               }
           }
         if(TDList->slider ==ret)
           {

             TDList->slider=Next;
           }
         TDList->length--;
       }
     return ret;
   }

   DLinkListNode* DLinkList_DeleteNode(DLinkList* list,DLinkListNode* node)
   {
     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret= NULL;
     int i=0;
     if(TDList !=NULL)
       {

         DLinkListNode* current =(DLinkListNode*)TDList;
         for(i=0;i<TDList->length;i++)
           {

             if(current->next==node)
               {

                 ret=current->next;
                 break;
               }
             current=current->next;
           }
         if(ret !=NULL)
           {

             DLinkList_Delete(TDList,i);
           }
       }
     return ret;

   }

   DLinkListNode* DLinkList_Reset(DLinkList* list)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret=NULL;
     if(TDList != NULL)
       {

         TDList->slider=TDList->header.next;
         ret=TDList->slider;
       }
     return ret;

   }
   DLinkListNode* DLinkList_Current(DLinkList* list)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret=NULL;
     if(TDList != NULL)
       {

         ret=TDList->slider;
       }
     return ret;
   }
   DLinkListNode* DLinkList_Next(DLinkList* list)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret=NULL;
     if((TDList != NULL) && (TDList->slider != NULL))
       {
         ret=TDList->slider;
         TDList->slider=ret->next;

       }
     return ret;
   }
   DLinkListNode* DLinkList_pre(DLinkList* list)
   {

     TDLinkList* TDList=(TDLinkList*)list;
     DLinkListNode* ret=NULL;
     if((TDList != NULL) && (TDList->slider != NULL))
       {

         ret= TDList->slider;
         TDList->slider =ret->pre;
       }
     return ret;
   }
#+END_SRC
**** 主函数
#+BEGIN_SRC C 
    #include <stdio.h>
    #include <stdlib.h>
    #include "DLinkList.h"
    /* run this program using the console pauser or add your own getch, system("pause") or input loop */

    struct Value
    {
      DLinkListNode header;
      int v;
    };

    int main(int argc, char *argv[])
    {

      DLinkList* list = DLinkList_Create();

      struct Value v1;
      struct Value v2;
      struct Value v3;
      struct Value v4;
      struct Value v5;

      v1.v = 1;
      v2.v = 2;
      v3.v = 3;
      v4.v = 4;
      v5.v = 5;

      DLinkList_Insert(list, (DLinkListNode*)&v1, 0);
      DLinkList_Insert(list, (DLinkListNode*)&v2, 0);
      DLinkList_Insert(list, (DLinkListNode*)&v3, 0);
      DLinkList_Insert(list, (DLinkListNode*)&v4, 0);
      DLinkList_Insert(list, (DLinkListNode*)&v5, 0);

      DLinkList_Reset(list);
  struct Value *pv = (struct Value*)DLinkList_Get(list, 0);
      printf("%d" ,pv->v);

      //DLinkList_Pre(list);

      // printf("%x\n", DLinkList_Current(list));

      DLinkList_Destroy(list);

      return 0;
    }

#+END_SRC
** 老师代码
*** 线性表
**** 头文件
#+BEGIN_SRC C
  #define N 50
  #define SIZE 100
  typedef struct book {
    int no;
    char name[N];
  }Book;

  typedef Book datatype;

  typedef struct {
    datatype data[SIZE];
    int last;
  }sqlist;

  sqlist * list_create();
  void list_clear(sqlist * L);
  int list_empty(sqlist * L);
  int list_locate(sqlist * L, datatype value);
  int list_insert(sqlist * L, datatype value, int pos);
  int list_delete(sqlist * L, int pos);
  int list_show(sqlist * L);

#+END_SRC
**** 源代码文件
#+BEGIN_SRC  C
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "sqlist.h"

  /*
   ,* create a empty list
   ,* @ret:start address
   ,* */
  sqlist * list_create() {
      sqlist * L;

      if ((L = (sqlist *)malloc(sizeof(sqlist))) == NULL) {
          printf("malloc failed\n");
          return NULL;
      }

      L->last = -1;
      return L;
  }

  void list_clear(sqlist * L) {
      L->last = -1;
  //  free(L);
  //  L=NULL;
  }

  /*
   ,* @ret: 1  empty
   ,* */
  int list_empty(sqlist * L) {
      return ((L->last == -1) ? 1 : 0);
  }

  int list_locate(sqlist * L, datatype value) {
      int i;

      for (i = 0; i <= L->last; ) {
      //  if((L->data[i].no == value.no) && 
                  //strcmp(L->data[i].name, value.name) == 0) {
          if (memcmp(&(L->data[i]), &value, sizeof(Book)) != 0) {
              i++;
          }
          else 
              return i;
      }

      return -1;
  }

  int list_insert(sqlist * L, datatype value, int pos) {
      //list is full
      if (L->last == SIZE - 1) {
          printf("full\n");
          return -1;
      }

      //pos [0,last+1]
      if (pos < 0 || pos > L->last+1) {
          printf("insert position is invalid\n");
          return -1;
      }

      int i;
      for (i = L->last; i >= pos; i--) {
          L->data[i+1] = L->data[i];
      }
      L->data[pos] = value;
      L->last++;
      return 0;
  }

  int list_delete(sqlist * L, int pos) {
      if (L->last == - 1) {
          printf("empty\n");
          return -1;
      }

      //pos [0, last]
      if (pos < 0 || pos > L->last) {
          printf("Delete position is invalid\n");
          return -1;
      }

      int i;

      for (i = pos+1; i <= L->last; i++){
          L->data[i-1] = L->data[i];
      }
      L->last--;

      return 0;
  }

  int list_show(sqlist * L) {
      int i;

      puts("-------------------");
      for (i = 0; i <= L->last; i++) {
          printf("%d %s\n", L->data[i].no, L->data[i].name);
      }

      return 0;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>
  #include "sqlist.h"

  int main(int argc, const char *argv[])
  {
    Book arr[] = {{1, "clang"}, {2, "math"}, {3, "C"}};
    sqlist * L = NULL;
    int i;

    L = list_create();//empty list

    for (i = 0; i < sizeof(arr)/sizeof(Book); i++) {
      list_insert(L, arr[i], i);
    }

    list_show(L);

    Book tmp={2, "math"};

    if (list_locate(L, tmp) == -1) {
      printf("not exist\n");
    }
    else {
      printf("exist\n");
    }

    list_show(L);



    /*

      Book book1={8, "C++"};
      list_insert(L, book1, 4);

      list_show(L);

      //list_delete(L, 2);
      list_show(L);


      if (memcmp(&book1, &book2, sizeof(Book)) == 0){
      printf("=\n");
      }
      else {
      printf("!=\n");
      }
    ,*/
    
    return 0;
  }

#+END_SRC
*** 单链表
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;

  typedef struct node {
    datatype data;
    struct node * next;
  }listnode, *linklist;//typedef struct node * linklist;

  linklist list_create();
  linklist head_insert(linklist H, datatype value);
  void list_show(linklist H);
  linklist list_insert(linklist H, datatype value, int pos);
  linklist list_delete(linklist H, int pos);
  int list_sort(linklist H);
  int list_reverse(linklist H);

#+END_SRC
**** 源代码文件
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "linklist.h"

  linklist list_create() {
      linklist H;

      if((H = (linklist)malloc(sizeof(listnode))) == NULL) {
          printf("malloc faild\n");
          return NULL;
      }
      H->next = NULL;

      return H;
  }


  int head_insert(linklist H, datatype value) {
      linklist p;

      if((p = (linklist)malloc(sizeof(listnode))) == NULL) {
          printf("malloc faild\n");
          return -1;
      }
      p->data = value;

      p->next = H->next;
      H->next = p;
  
      return 0; 
  }


  void list_show(linklist H) {
      while (H->next != NULL) {
          printf("%d ", H->next->data);
          H = H->next;
      }
      puts("");
  }

  int list_insert(linklist H, datatype value, int pos) {
      linklist p = H, q;
      int i = 0;

      if (pos < 0) {
          printf("Insert pos invald\n");
          return -1;
      }

      while (i < pos) {
          p = p->next;
          if (p == NULL) {
              printf("Insert pos invald\n");
              return -1;
          }
          i++;
      }

      if((q = (linklist)malloc(sizeof(listnode))) == NULL) {
          printf("malloc faild\n");
          return -1;
      }
      q->data = value;

      q->next = p->next;
      p->next = q;

      return 0;
  }

  int list_delete(linklist H, int pos) {
      linklist p = H, q;
      int i = 0;

      if (pos < 0) {
          printf("Delete pos invalid\n");
          return -1;
      }

      while (i < pos) {
          p = p->next;
          if (p == NULL) {
              printf("Delete pos invalid\n");
              return -1;
          }
          i++;
      }
      if (p->next == NULL) {
          printf("Delete pos invalid\n");
          return -1;
      }

      q = p->next;
      p->next = q->next;
      free(q);
      q = NULL;

      return 0;
  }

  int list_sort(linklist H){
      linklist p = H->next, q, r;
      H->next = NULL;

      while (p != NULL) {
          q = p;
          p = p->next;

          r = H;
          while (r->next != NULL && r->next->data < q->data) {
              r = r->next;
          }
          q->next = r->next;
          r->next = q;
      }
      return 0;
  }

  int list_reverse(linklist H) {
      linklist p = H->next, q;
      H->next = NULL;

      while (p != NULL) {
          q = p;
          p = p->next;
  
          q->next = H->next;
          H->next = q;
      }

      return 0;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  nclude <stdio.h>
  #include <stdlib.h>
  #include "linklist.h"

  int main(int argc, const char *argv[])
  {
    linklist H = NULL;

    H = list_create();

    head_insert(H, 10);
    head_insert(H, 80);
    head_insert(H, 20);

    list_show(H);
    list_insert(H, 30, 2);
    list_show(H);

    list_delete(H, 4);
    list_show(H);

    list_reverse(H);
    list_show(H);

    list_sort(H);
    list_show(H);

    return 0;
  }

#+END_SRC
* 第二天<2016-07-22 Fri> 
** 代码练习
*** 链式栈
**** 头文件
#+BEGIN_SRC  C :main no :tangle LinkStack.h : dir ~/homework
  typedef int datatype;
  typedef  void LinkStack ;
  typedef struct _tag_LinkStackNode LinkStackNode;
  struct _tag_LinkStackNode {
    LinkStackNode* next;
  };

  LinkStack* LinkStack_Create();

  int LinkStack_Push(LinkStack* stack,LinkListNode* node);
  void* LinkStack_Pop(LinkStack* stack);
  int LinkStack_Clear(LinkStack* stack);
  int LinkStack_Empty(LinkStack* stack);
  void* LinkStack_Top(LinkStack* stack);

#+END_SRC
**** 源代码文件
#+BEGIN_SRC  C :main no :tangle LinkStack.c :dir ~/homework
  #include <stdio.h>
  #include <stdlib.h>
  #include "LinkStack.h"
  typedef struct _tag_LinkStack
  {

    LinkStackNode header;
    int length;
  }TLinkStack;

  LinkStack* LinkStack_Create()
  {

    TLinkStack* ret=(TLinkStack*)malloc(sizeof(TLinkStack));
    if(ret == NULL)
      {

        printf("malloc LinkStack failed");
      }else{
      ret->length=0;
      ret->header.next=NULL;

    }
    return ret;
  }

  int LinkStack_Push(LinkStack* stack,LinkListNode* node)
  {
    TLinkStack* TStack=(TLinkStack*)stack;
    int ret=(TStack != NULL) && (node != NULL);
    if(ret)
      {
        LinkStackNode* current=(LinkStackNode*)TStack;
        node->next=current->next;
        current->next=node;
        TStack->length++;
      }
    return ret;
  }

  LinkStackNode* LinkStack_Pop(LinkStack* stack)
  {

    TLinkStack* TStack=(TLinkStack*)stack;
    LinkStackNode* ret=NULL;
    if(TStack != NULL && TStack->length>0)
      {

        LinkListNode* current=(LinkListNode*)TStack;
            ret=current->next;

    
      }
  }
  void* LinkStack_Top(LinkStack* stack)
  {

    TLinkStack* TStack=(TLinkStack*)stack;
    LinkStackNode* node=(LinkStackNode*)TStack;
    void* ret=NULL;
    if(TStack !=NULL && node->next != NULL )
      {
        ret=node->next;

      }
    return ret;
  }



#+END_SRC
**** 主函数
#+BEGIN_SRC C

#+END_SRC

*** 顺序队列
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;
  #define N 5

  typedef struct {
    datatype data[N];
    int front;
    int rear;
  }sequeue;

  sequeue * queue_create();
  int queue_empty(sequeue *sq);
  int inqueue(sequeue * sq, datatype value);
  datatype dequeue(sequeue * sq);
  int queue_full(sequeue * sq);
  int queue_clear(sequeue * sq);
  typedef int datatype;
  #define N 5

#+END_SRC
**** 源代码文件
#+BEGIN_SRC c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "sequeue.h"

  sequeue * queue_create() {
    sequeue* ret=NULL;
    ret=(sequeue*)malloc(sizeof(sequeue));
    if(ret=NULL)
      {

        printf("malloc sequeue failed");
        return ret;
      }
    bzero(sq->data,sizeof(sq->data));
    ret->front=0;
    ret->rear=0;
    return ret;
  }
  int queue_empty(sequeue *sq) {

    int ret=(sq != NULL);
    if(ret)
      {

        if(sq->front==sq->rear)
          {

            return ret;
          }else{
          return 0;
        }

      }
    return ret;
  }
  int inqueue(sequeue * sq, datatype value){
    int ret=(sq != NULL) && (rear+1)%N != front;
    if(ret)
      {
        sq->node[sq->rear]=value;
        sq->rear=(sq->rear+1)/N;
   
      }
    return ret;
  }
  datatype dequeue(sequeue * sq){
    int ret=(sq != NULL)&& (sq->front != sq->rear);
    if(ret) {
      sq->ret=sq->node[sq->front];
      sq->front=(sq->front+1)%N;

      }
    return ret;
  }
  int queue_full(sequeue * sq){
    int ret=(sq != NULL);
    if(ret && (sq->rear+1)%N == sq->front)
      {
        return ret;

      }
    return ret;
  }
  int queue_clear(sequeue * sq){
    int ret=(sq != NULL)
      if(ret) {

        sq->front == sq->rear;
      }
    return ret;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "sequeue.h"

  int main(int argc, const char *argv[])
  {
    sequeue * sq;

    if ((sq = queue_create()) == NULL) {
      return 0;
    }
    
    enqueue(sq, 30);
    enqueue(sq, 60);
    enqueue(sq, 90);

    while (!queue_empty(sq)) {
      printf("%d ", dequeue(sq));
    }
    puts("");
    free(sq);
    sq=NULL;
    return 0;
  }
#+END_SRC
**** Makefile
#+BEGIN_SRC makefile
  OBJS=SeqQueue.o main.o
  CC=gcc
  CFLAGS= -g -Wall
  SeqQueue:$(OBJS)
      $(CC) $(CFLAGS) -o $@ $^
  SeqQueue.o:SeqQueue.c SeqQueue.h
      $(CC) $(CFLAGS) -o $@ $^
  main.o:main.c SeqQueue.h
      $(CC) $(CFLAGS) -o $@ $^

#+END_SRC
*** 链式队列
**** 头文件
#+BEGIN_SRC C :main no :tangle LinkQueue.h :dir ~/homework
  typedef int LinkQueueNode;
  typedef struct _tag_LinkQueue {
    LinkQueueNode data;
    struct _tag_LinkQueue *next;
  }listnode,*linklist;

  typedef struct {

    linklist front;
    linklist rear;
  }linkqueue;
  linkqueue*  queue_create();
  int queue_empty(linkqueue *lqueue);
  int enqueue(linkqueue *lq,LinkQueueNode value);
  LinkQueueNode dequeue(linkqueue *lqueue);
  int queue_clear(linkqueue *lqueue);
#+END_SRC
**** 源代码文件
#+BEGIN_SRC C :main no :tangle LinkQueue.c :dir ~/homework
  #include <stdio.h>
  #include<stdlib.h>
  #include<string.h>
  #include"LinkQueue.h"
  /*
    先在堆空间上申请表头,申请成功后初始化表头
    然后在堆空间上申请头指针和尾指针,申请成功后初始化.
    空队列头指针和尾指针都指向表头

  ,*/
  linkqueue* queue_create() {
    linklist list=(linklist)malloc(sizeof(listnode));
    linkqueue* ret=(linkqueue*)malloc(sizeof(linkqueue));

    if(list !=NULL)
      {

        list->data=0;
        list->next=NULL;
      }else
      {
        printf("malloc listnode failed");
        return NULL;
      }


    if(ret !=NULL)
      {

        ret->front=list;
        ret->rear=list;
      }else
      {
        printf("malloc linkqueue failed");
        return NULL;

      }

    return ret;
  }


  int queue_empty(linkqueue *lqueue) {

    return (lqueue !=NULL) && (lqueue->front ==lqueue->rear ? 1:0);
  }

  /*
    首先在堆空间上申请元素空间,申请成功后.
    申请成功后赋值,因为是尾插,所以指针域指向空,数据与赋值为传进来的数据
    然后把上个元素的 next 指针指向插入的元素
    最后把标识尾部的 rear 指针指向该元素
  ,*/
  int enqueue(linkqueue *lqueue,LinkQueueNode value) {
    linklist node=(linklist)malloc(sizeof(listnode));
    if(node != NULL)
      {

        node->data=value;
        node->next=NULL;
        lqueue->rear->next=node;
        lqueue->rear=node;
        return 0;
      }else
      {

        printf("malloc linklist failed");
        return -1;
      }

  }
  /*
     先把表头指向的第一个元素(即要删除释放的元素)赋值给一个临时变量
     然后把 front 指向临时变量的 next(即临时变量的下一个元素),因为 front 指针是用来标识第一个元素的.  
     然后释放临时变量(tmp)的空间,把 tmp 置空

     返回的值是当前表头所值的第一个元素)(即队列的第一个元素)  
  ,*/
  LinkQueueNode dequeue(linkqueue *lqueue) {

    if(lqueue != NULL)
      {
        listnode* tmp=lqueue->front;

        lqueue->front=tmp->next;
        free(tmp);
        tmp=NULL;
      }
    return (lqueue->front->data);
  }


  /*
    相当与删除所有元素,与删除的原理相同
  ,*/


  int queue_clear(linkqueue *lqueue) {

    if(lqueue !=NULL)
      {
        listnode* tmp=lqueue->front;

        while(lqueue->front != NULL)
          {
            tmp=lqueue->front;
            lqueue->front=tmp->next;
            free(tmp);
            tmp=NULL;

          }
      }
    return 0;
  }
  /*
    清空队列后,再加一步释放 front rear 指针
  ,*/
  int queue_free(linkqueue *lqueue) {
    if(lqueue !=NULL)
      {

        listnode* tmp=lqueue->front;
        while(lqueue->front != NULL)
          {
            tmp=lqueue->front;
            lqueue->front=tmp->next;
            free(tmp);
            tmp=NULL;
          }
        free(lqueue);
        lqueue=NULL;
      }
    return 0;

  }


#+END_SRC
**** 主函数
#+BEGIN_SRC C :main no :tangle main.c :dir ~/homework
    #include <stdio.h>
    #include <stdlib.h>
    #include "LinkQueue.h"

    int main(int argc, const char *argv[])
    {
      linkqueue * lq;

      lq = queue_create();

      enqueue(lq, 1);
      enqueue(lq, 91);
      enqueue(lq, 7);
      enqueue(lq, 86);

      //queue_free(lq);
      //queue_clear(lq);
  
      while (!queue_empty(lq)) {
        printf("%d ", dequeue(lq));
      }
      //queue_free(lq);
      puts("");


      return 0;
    }
#+END_SRC
** 老师代码
*** 链式栈
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;

  typedef struct node{
    datatype data;
    struct node * next;
  }listnode, *linkstack;

  linkstack stack_create();
  int push(linkstack s, datatype value);
  datatype pop(linkstack s);
  int stack_free(linkstack s);
  int stack_empty(linkstack s);
  datatype top(linkstack s);

#+END_SRC
**** 源代码文件
#+BEGIN_SRC  C
  #include <stdio.h>
  #include <stdlib.h>
  #include "stack.h"

  linkstack stack_create() {
    linkstack s;

    if ((s = (linkstack)malloc(sizeof(listnode))) == NULL) {
      printf("malloc faild\n");
      return NULL;
    }
    s->data = 0;
    s->next = NULL;

    return s;
  }

  int push(linkstack s, datatype value) {
    linkstack p;

    if ((p = (linkstack)malloc(sizeof(listnode))) == NULL) {
      printf("malloc faild\n");
      return -1;
    }
    p->data = value;

    p->next = s->next;
    s->next = p;
    
    return 0;
  }

  datatype pop(linkstack s) {
    linkstack p;
    datatype ret;

    p = s->next;
    s->next = p->next;

    ret = p->data;
    free(p);
    p = NULL;

    return ret;
  }

  int stack_free(linkstack s) {
    linkstack p;

    printf("free:");
    while (s != NULL) {
      p = s;
      s = s->next;
      printf("%d ", p->data);
      free(p);
      p = NULL;
    }
    puts("");

    return 0;
  }

  /*
   ,* ret:1 empty   
   ,* */
  int stack_empty(linkstack s) {
    return  (s->next == NULL);
  }

  datatype top(linkstack s) {
    return (s->next->data);
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>
  #include "stack.h"

  int main(int argc, const char *argv[])
  {
    linkstack s;

    if ((s = stack_create()) == NULL) {
      return 0;
    }

    push(s, 69);
    push(s, 39);
    push(s, 19);

    stack_free(s);

  #if 0
    if (!stack_empty(s) ) {
      printf("top:%d\n", top(s));
    }

    while (!stack_empty(s)) {
      printf("%d \n", pop(s) );
    }
  #endif

    return 0;
  }

#+END_SRC
*** 线性队列
**** 头文件
#+BEGIN_SRC C
  typedef int sequeuenode;
  #define N 100

  typedef struct {
    sequeuenode data[N];
    int front;
    int rear;
  }sequeue;

  sequeue * queue_create();
  int queue_empty(sequeue *sq);
  int enqueue(sequeue * sq, sequeuenode value);
  sequeuenode dequeue(sequeue * sq);
  int queue_full(sequeue * sq);
  int queue_clear(sequeue * sq);

#+END_SRC
**** 源代码文件
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include <strings.h>
  #include "sequeue.h"

  sequeue * queue_create() {
    sequeue * sq;

    if ((sq = (sequeue *)malloc(sizeof(sequeue))) == NULL) {
      printf("malloc\n");
      return NULL;
    }
    bzero(sq->data, sizeof(sq->data));
    sq->front = sq->rear = 0;
    return sq;
  }

  int queue_empty(sequeue *sq){
    if (sq->front == sq->rear) {
      return 1;
    }
    else {
      return 0;
    }
  }

  int enqueue(sequeue * sq, sequeuenode value){
    if ((sq->rear+1) % N == sq->front) {
      printf("full\n");
      return -1;
    }
    sq->data[sq->rear] = value;
    sq->rear = (sq->rear + 1) % N;

    return 0;
  }

  sequeuenode dequeue(sequeue * sq){
    sequeuenode ret;

    ret = sq->data[sq->front];

    sq->front = (sq->front+1) % N;

    return ret;
  }


  int queue_full(sequeue * sq){
    if ((sq->rear+1) % N == sq->front) {
      return 1;
    }
    else {
      return 0;
    }
  }

  int queue_clear(sequeue * sq){
    bzero(sq->data, sizeof(sq->data));
    sq->front = sq->rear;

    return 0;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "sequeue.h"

  int main(int argc, const char *argv[])
  {
    sequeue * sq;

    if ((sq = queue_create()) == NULL) {
      return 0;
    }
    
    enqueue(sq, 30);
    enqueue(sq, 60);
    enqueue(sq, 90);
    enqueue(sq, 120);
    enqueue(sq, 150);

    while (!queue_empty(sq)) {
      printf("%d ", dequeue(sq));
    }
    puts("");


    free(sq);
    sq = NULL;

    return 0;
  }

#+END_SRC
*** 链式队列
**** 头文件
#+BEGIN_SRC C :main no :tangle LinkQueue.h
  #ifndef _LINKQUEUE_H_
  #define _LINKQUEUE_H_
  #include "BTree.h"
  typedef bitree* linkqueuenode;

  typedef struct _tag_linkqueue {
    linkqueuenode data;
    struct _tag_linkqueue * next;
  }listnode, * linklist;

  typedef struct {
    linklist front;//listnode * front;  //struct node * front;
    linklist rear;
  }linkqueue;

  linkqueue * queue_create();
  int queue_empty(linkqueue * lq);
  int enqueue(linkqueue *lq, linkqueuenode value);
  linkqueuenode dequeue(linkqueue *lq);
  int queue_clear(linkqueue *lq);
  int queue_free(linkqueue *lq);

  #endif
#+END_SRC
**** 源代码文件
#+BEGIN_SRC C :main no :tangle LinkQueue.c
  #include <stdio.h>
  #include <stdlib.h>
  #include "LinkQueue.h"

  linkqueue * queue_create() {
      linklist p;
      linkqueue * lq;

      if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
          return NULL;
      }
      p->data = 0;
      p->next = NULL;

      if ((lq = (linkqueue*)malloc(sizeof(linkqueue))) == NULL) {
          return NULL;
      }
      lq->front = p;
      lq->rear = p;

      printf("%p\n", lq);
      return lq;
  }

  int queue_empty(linkqueue * lq) {
      return (lq->front->next == NULL);
      //return (lq->front == lq->rear);
  }

  int enqueue(linkqueue *lq, linkqueuenode value) {
      linklist p;

      if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
          return -1;
      }
      p->data = value;
      p->next=NULL;
      lq->rear->next = p;
      lq->rear = p;

      return 0;
  }

  linkqueuenode dequeue(linkqueue *lq) {
      linklist p;
      p  = lq->front;
      lq->front = p->next;
      free(p);
      p = NULL;

      return (lq->front->data);
  }

  int queue_clear(linkqueue *lq) {
      linklist p;

      printf("clear:");
      while (lq->front->next != NULL) {
          p = lq->front;
          lq->front = p->next;
          //printf("%d ", p->data);
          free(p);
      }

      return 0;
  }

  int queue_free(linkqueue *lq) {
      linklist p;

      p = lq->front;

      printf("free:");
      while (p != NULL) {
          lq->front = p->next;
          // printf("%d ", p->data);
          free(p);
          p = lq->front;
      }
      puts("");

      printf("%p\n", lq);
      free(lq);

      return 0;
  }

#+END_SRC

**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "linkqueue.h"

  int main(int argc, const char *argv[])
  {
    linkqueue * lq;

    lq = queue_create();

    enqueue(lq, 1);
    enqueue(lq, 91);
    enqueue(lq, 7);
    enqueue(lq, 86);

    queue_free(lq);
    //queue_clear(lq);
  #if 0
    while (!queue_empty(lq)) {
      printf("%d ", dequeue(lq));
    }
  #endif

    puts("");


    return 0;
  }

#+END_SRC
* 第三天<2016-07-22 sa>
** 代码练习
*** 通用树结构
**** 头文件
#+BEGIN_SRC C
  #ifndef _GTREE_H_
  #define _GTREE_H_

  typedef void GTree;
  typedef void GTreeData;
  typedef void (GTree_Printf)(GTreeData*);

  GTree* GTree_Create();

  void GTree_Destroy(GTree* tree);

  void GTree_Clear(GTree* tree);

  int GTree_Insert(GTree* tree, GTreeData* data, int pPos);

  GTreeData* GTree_Delete(GTree* tree, int pos);

  GTreeData* GTree_Get(GTree* tree, int pos);

  GTreeData* GTree_Root(GTree* tree);

  int GTree_Height(GTree* tree);

  int GTree_Count(GTree* tree);

  int GTree_Degree(GTree* tree);

  void GTree_Display(GTree* tree, GTree_Printf* pFunc, int gap, char div);

  #endif


#+END_SRC
**** 源代码文件
#+BEGIN_SRC C
  #include <stdio.h>
  #include<stdlib.h>
  #include"GTree.h"
  #include"LinkList.h"
  typedef struct _tag_GTreeeNode GTreeNode;
  struct _tag_GTreeeNode
  {

      GTreeNodeData* data;
      GTreeNode* parent;
      LinkList* child;
  };

  typedef struct _tag_TLNode TLNode;
  struct _tag_TLNode
  {

      LinkListNode header;
      GTreeNode* node;
  };

  GTree* GTree_Create()
  {

      return LinkList_Create;
  }

  void GTree_Destroy()
  {

      GTree_Clear(tree);
      LinkList_Destroy(tree);
  }
  /*
  1.整棵树用链表来组织,元素在组织链表中的位置和元素在树中的位置无关
  2.元素插入时是把它当作某个元素的孩子节点来插入,元素的实际位置其实就是在孩子链表中.
  3.首先为插入的节点申请空间(cNode),然后为元素初始化,data等于传进来的数据,parent先赋值为空,因为我们不知道它是否有父亲节点,其孩子节点是一个链表,即创建一个链表即可.
  4.其次为其申请树节点(trNode)空间,因为我们要将其插入树节点,即组织链表中
  5.然后为其申一个孩子节点空间(cldNode),因为我们要将其作为某个元素的孩子节点插入其孩子的链表.
  6.然后然树节点指向cNode
  7.让孩子节点指向cnode
  8.调用链表插入函数,把trNode插入组织链表
  9.然后调用函数得到父亲节点,因为我需要将节点的parent指针指向Pnode,假如PNode不为空,我们将cNode的parent 指针指向PNode
  10.然后我们调用插入函数,将cldNode节点插入PNode的child链表.
  11.假如PNode为空,则释放所有申请的空间

   ,*/
  int GTree_Insert(GTree* tree,GTreeData* data,int pPos)
  {
      LinkList* list=(LinkList*)tree;
      int ret=(list != NULL) && (data != NULL)&& (0<=pPos)&&(pPos <LinkList_Length(list));
      if(ret)
      {
          GTreeNode* cNode=(GTreeNode*)malloc(sizeof(GTreeNode));
          TLNode* trNode=(TLNode*)malloc(sizeof(TLNode));
          TLNode* cldNode=(TLNode*)malloc(sizeof(TLNode));
          TLNode* pNode=(TLNode*)LinkList_Get(list,pPos);
          ret=(cNode != NULL) && (trNode != NULL) &&(cldNode != NULL);
          if(ret)
          {

              cNode->data=data;
              cNode->parent=NULL;
              cNode->child=LinkList_Create();

              trNode->node=node;
              cldNode->node=node;

              LinkList_Insert(list,(LinkListNode*))trNode,LinkList_Length(list);
              if(pNode !=NULL)
              {

                  cNode->parent=pNode->node;
                  LinkList_Insert(pNode->node->child,(LinkListNode*)cldNode,LinkList_Length(pNode->node->child));
              }
          }else
          {

              free(cNode);
              cNode=NULL;
              free(trNode);
              trNode(NULL);
              free(cldNode);
              cldNode=NULL;
          }

      }
      return ret;

  }

  GTreeData* GTree_Delete(GTree* tree,int pos)
  {

      TLNode* trNode=(TLNode*)LinkList_Get_ByPos(tree,pos);
  }




#+END_SRC
*** 二叉树
**** 头文件
#+BEGIN_SRC C :main no : BTree.h
  #ifndef _BTREE_H_
  #define _BTREE_H_
  typedef char btreenode;

    typedef struct _tag_bitree{
        btreenode data;
        struct _tag_bitree * left;
        struct _tag_bitree * right;
    }bitree;

    bitree * tree_create();
    void preorder(bitree * r);
    void inorder(bitree * r);
    void postorder(bitree * r);
    void layerorder(bitree * r);
  bitree* fulltree_create(char ch[],int n,int i);
  #endif
#+END_SRC
**** 源代码文件
#+BEGIN_SRC C :main no : BTree.c
  #include <stdio.h>
  #include <stdlib.h>
  #include "BTree.h"
  #include "LinkQueue.h"
  bitree * tree_create()
  {
      bitree* ret;
      char ch;
      printf("please input tree");
      scanf("%c",&ch);
      if(ch != '#')
      {
          ret=(bitree*)malloc(sizeof(bitree));

          if(ret !=NULL)
          {

              ret->data=ch;
              ret->left=tree_create();
              ret->right=tree_create();
          }else
          {

              printf("malloc bitree failed");
              return NULL;
          }

      }else
      {

          return NULL;
      }

      return ret;

  }
  bitree* fulltree_create(char ch[],int n,int i)
  {

              bitree* ret=(bitree*)malloc(sizeof(bitree));
              if(ret ==NULL)
              {

                  return NULL;
              }else
              {
                  ret->data=ch[i];
                  if(2 * i <= n)
                  {
                      ret->left=fulltree_create( ch, n, 2*i);

                  }
                  if(2 * i + 1 <=n)
                  {
                      ret->right=fulltree_create(ch,n, 2*i+1);
                  }

              }

              return ret;


      }



  void preorder(bitree * r)
  {
      if(r != NULL)
      {

          printf("%c",r->data);
          preorder(r->left);
          preorder(r->right);
      }

  }
  void inorder(bitree * r)
  {
      if(r !=NULL)
      {

          inorder(r->left);
          printf("%c",r->data);
          inorder(r->right);
      }
  }
  void postorder(bitree * r)
  {
      if(r != NULL)
      {

          inorder(r->left);
          inorder(r->right);
          printf("%c",r->data);
      }
  }
  void layerorder(bitree * r)
  {

      if(r != NULL)
      {
          linkqueue* queue=queue_create();
          enqueue(queue,r);
          while(!queue_empty(queue))
          {
              bitree* trNode=dequeue(queue);
              printf("%c",trNode->data);
              if(trNode->left)
              {
                  enqueue(queue,trNode->left);
              }

              if(r->right)
              {
                  enqueue(queue,trNode->right);
              }

          }


      }
  }

#+END_SRC
**** 测试函数
#+BEGIN_SRC C :main no :main.c
  #include <stdio.h>
  #include "BTree.h"
  #include "LinkQueue.h"
  int main(int argc, const char *argv[])
  {
      bitree * r;

      //r = tree_create();

      char ch[]={' ','a','b','c','d','e','f'};
      int n=sizeof(ch)/sizeof(char);
      int i=1;
      r=fulltree_create(ch,n,i);

      preorder(r);
      puts("");

      inorder(r);
      puts("");

      postorder(r);
      puts("");

      layerorder(r);
      return 0;
  }

#+END_SRC
**** Makefile
#+BEGIN_SRC makefile
  OBJS=BTree.o main.o
  CC=gcc
  CFLAGS= -g -Wall
  BTree:BTree.o main.o
      $(CC) $(CFLAGS) -o $@ @^
  BTree.o:BTree.c
      $(CC) $(CFLAGS) -c $@ $<
  main.o:main.c
      $(CC) $(CFLAGS) -c $@ $<
  clean:
      rm *.o BTree
#+END_SRC
