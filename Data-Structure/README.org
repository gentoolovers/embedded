* 第一天<2016-07-21 Thu>
** 数据结构的概念
+ 数据结构 :指数据之间的相互关系,包含下面三方面的内容
+ 逻辑结构 :表示数据运算之间的抽象关系(如邻接关系,从属关系),按每个元素可能具有的直接前趋数和直接后继数将逻辑
结构分为"线性结构"和非线性结构两大类.
+ 存储结构 :逻辑结构在计算机之间的具体实现方法,分为顺序存储方法,链接存储方法,索引存储方法,散列存储方法.
+ 数据运算 :对数据进行的操作,如插入,删除,查找,排序.
** 代码练习
*** 线性表
**** 头文件
#+BEGIN_SRC C :main no 
  #ifndef  _SEQLIST_H
  #define  _SEQLIST_H
  #define N 50
  #define SIZE 100
  typedef Book DataType;
  typedef struct book {
    int no;
    char name[N];

  }Book;

  typedef struct {

    DataType data[SIZE];
    int last;
  }SeqList;
  SeqList* SeqList_Create();
  int SeqList_Empty(SeqList *L);
  int SeqList_Locate(SeqList *L,DataType value);
  int SeqList_Insert(SeqList *L,DataType value,int Pos);
  int SeqList_DeLete(SeqList *L,int Pos);
  int SeqList_Show(SqList *L);
  #endif
#+END_SRC
**** 实现文件
#+BEGIN_SRC C :main no 
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "SeqList.h"
  SeqList* SeqList_Create()
  {

    SeqList* L=NULL;
    if((L=(SeqList*)malloc(sizeof(SeqList))) == NULL)
      {

        printf("malloc failed\n");
        return NULL;
      }
    L->last = -1;
    return L;
  }
  /*
    如果线性表是空的返回 0,如果不是空的返回线性表的长度
   ,*/
  int SeqList_Empty(SeqList *L)
  {

    if(L->last == -1)
      {

        return 0; 
      }
    return L->last+1;
  }
  /*
    假如有这个元素返回该元素的下标,没有返回-1;
   ,*/
  int SeqList_Locate(SeqList *L,DataType value)
  {
    int i=0;
    for(i=0;i<=L->last,i++)
      {
        if(memcmp(&L->data[i],&value,sizeof(Book)))
          {
            return i;
          }
      }
    return -1;

  }
  int SeqList_Insert(SeqList *L,DataType value,int Pos)
  {
    int ret=(0<=Pos)&&((L->last +1)<sizeof(L));
      if(ret && (Pos>=L->last+1))
        {
          Pos=L->last+1;

        }
      for(i=L->last;i>=Pos;i++)
      {
        L->data[i+1]=L->data[i];

      }
      L->data[Pos]=value;
      L->last++;
      return ret;
  }
  int SeqList_DeLete(SeqList *L,int Pos)
  {

    int ret=(0<=Pos)&&(Pos<=L->last);
    int i=0;

      if(ret)
        {
           for(i=Pos;i<=L->last;i++)
              {

                 L->data[i]=L->data[i+1];
              }
               L->last--;
        }
    return ret;
  }
  int SeqList_Show(SqList *L)
  {
    int i=0;
    for(i=0;i<=L->last;i++)
      {

        printf("book number is %d\nbook name is %s",L->data[i].no,L->data[i].name);
      }
    return 0;

  }
#+END_SRC
**** main 函数
#+BEGIN_SRC C :main no :
  #include <stdio.h>
  int main(int argc,const char* argv[])
  {

    return 0;
  }
#+END_SRC
**** Makefile
#+BEGIN_SRC makefile :
  OBJS=SeqList.o main.o
  cc=gcc
  CFLAGS= -g -Wall
  SeqList:$(OBJS)
      $(cc) $(CFLAGS)  -o  $@ $^
  SeqList.o:SeqList.c SeqList.h
      $(cc) $(CFLAGS) -c $@ $<
  main.o:main.c SeqList.h
      $(cc) $(CFLAGS) -c $@ $<
#+END_SRC
*** 链表
**** 头文件
#+BEGIN_SRC C :main no :tangle LinkList.h
  typedef int datatype;
  typedef struct node {
    int data;
    struct node *next;
  }LinkList;

  LinkList* LinkList_Create();

  int LinkList_Insert(LinkList* list,datatype value,int pos);

  LinkList* LinkList_Delete(LinkList* list,int pos);

  int LinkList_Sort(LinkList* list);

  int LinkList_Reverse(LinkList* list);
#+END_SRC
**** 实现文件
#+BEGIN_SRC C :main no :tangle LinkList.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "LinkList.h"
  LinkList* LinkList_Create()
  {
    LinkList* ret=NULL;
    ret=(LinkList*)malloc(sizeof(LinkList));
    if(ret != NULL)
      {

        ret->data=0;
        ret->next=NULL;
      }else
      {

        printf("malloc failed");
      }
    return ret;

  }
  int LinkList_Insert(LinkList* list,datatype value,int pos)
  {
    int ret=(list != NULL)&&(pos>=0)&&(pos<=list->data);
    if(ret)
      {

        LinkList* node=(LinkList*)malloc(sizeof(LinkList));
        LinkList* current=list;
        int i=0;
        if(pos>list->data)
          {

            pos=list->data;
          }
        for(i=0;(i<pos)&&(current->next !=NULL);i++)
          {

            current=current->next;
          }
        node->next=current->next;
        node->data=value;
        current->next = node;
        list->data++;  

      }

    return ret;
  }
  LinkList* LinkList_Delete(LinkList* list,int pos)
  {

    LinkList* ret=NULL;
    if((list != NULL)&&( (pos>=0)&& (pos<=list->data)))
      {

        int i=0;
        LinkList* current=list;
        for(i=0;i<pos;i++)
          {
            current=current->next;

          }
        ret=current->next;
        current=ret->next;
        list->data--;

      }
    return ret;

  }

  void LinkList_Show(LinkList *H){
    if(H == NULL){
  
    }else
      {
        LinkList *p;
        p = H;
        while(p->next != NULL){
          printf("%d  ",p->data);
          p = p->next;
        }
        puts("");
      }
  }

#+END_SRC

**** 主函数
#+BEGIN_SRC  C :main no :tangle main.c
  #include <stdio.h>
  #include "LinkList.h"
  int main()
  {

    LinkList * H = NULL;
    H = LinkList_Create();
    int i = 0;
    for(i = 0; i < 5;i++)
      LinkList_Insert(H,i,0);


    LinkList_Show(H);
    return 0;
  }

#+END_SRC
**** Makefile
#+BEGIN_SRC makefile 
  OBJS=LinkList.o main.o
  CFLAGS=-g -Wall
  cc=gcc
  LinkList:$(OBJS)
      $(cc) $(CFLAGS) -o $@ $^
  SeqList.o:SeqList.c
      $(cc) $(CFLAGS) -o $@ $<
  main.o:main.c
      $(cc) $(CFLAGS) -o $@ $<
#+END_SRC

** 老师代码
*** 线性表
**** 头文件
#+BEGIN_SRC C
  #define N 50
  #define SIZE 100
  typedef struct book {
    int no;
    char name[N];
  }Book;

  typedef Book datatype;

  typedef struct {
    datatype data[SIZE];
    int last;
  }sqlist;

  sqlist * list_create();
  void list_clear(sqlist * L);
  int list_empty(sqlist * L);
  int list_locate(sqlist * L, datatype value);
  int list_insert(sqlist * L, datatype value, int pos);
  int list_delete(sqlist * L, int pos);
  int list_show(sqlist * L);

#+END_SRC
**** 实现文件
#+BEGIN_SRC  C
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "sqlist.h"

  /*
   ,* create a empty list
   ,* @ret:start address
   ,* */
  sqlist * list_create() {
      sqlist * L;

      if ((L = (sqlist *)malloc(sizeof(sqlist))) == NULL) {
          printf("malloc failed\n");
          return NULL;
      }

      L->last = -1;
      return L;
  }

  void list_clear(sqlist * L) {
      L->last = -1;
  //  free(L);
  //  L=NULL;
  }

  /*
   ,* @ret: 1  empty
   ,* */
  int list_empty(sqlist * L) {
      return ((L->last == -1) ? 1 : 0);
  }

  int list_locate(sqlist * L, datatype value) {
      int i;

      for (i = 0; i <= L->last; ) {
      //  if((L->data[i].no == value.no) && 
                  //strcmp(L->data[i].name, value.name) == 0) {
          if (memcmp(&(L->data[i]), &value, sizeof(Book)) != 0) {
              i++;
          }
          else 
              return i;
      }

      return -1;
  }

  int list_insert(sqlist * L, datatype value, int pos) {
      //list is full
      if (L->last == SIZE - 1) {
          printf("full\n");
          return -1;
      }

      //pos [0,last+1]
      if (pos < 0 || pos > L->last+1) {
          printf("insert position is invalid\n");
          return -1;
      }

      int i;
      for (i = L->last; i >= pos; i--) {
          L->data[i+1] = L->data[i];
      }
      L->data[pos] = value;
      L->last++;
      return 0;
  }

  int list_delete(sqlist * L, int pos) {
      if (L->last == - 1) {
          printf("empty\n");
          return -1;
      }

      //pos [0, last]
      if (pos < 0 || pos > L->last) {
          printf("Delete position is invalid\n");
          return -1;
      }

      int i;

      for (i = pos+1; i <= L->last; i++){
          L->data[i-1] = L->data[i];
      }
      L->last--;

      return 0;
  }

  int list_show(sqlist * L) {
      int i;

      puts("-------------------");
      for (i = 0; i <= L->last; i++) {
          printf("%d %s\n", L->data[i].no, L->data[i].name);
      }

      return 0;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>
  #include "sqlist.h"

  int main(int argc, const char *argv[])
  {
    Book arr[] = {{1, "clang"}, {2, "math"}, {3, "C"}};
    sqlist * L = NULL;
    int i;

    L = list_create();//empty list

    for (i = 0; i < sizeof(arr)/sizeof(Book); i++) {
      list_insert(L, arr[i], i);
    }

    list_show(L);

    Book tmp={2, "math"};

    if (list_locate(L, tmp) == -1) {
      printf("not exist\n");
    }
    else {
      printf("exist\n");
    }

    list_show(L);



    /*

      Book book1={8, "C++"};
      list_insert(L, book1, 4);

      list_show(L);

      //list_delete(L, 2);
      list_show(L);


      if (memcmp(&book1, &book2, sizeof(Book)) == 0){
      printf("=\n");
      }
      else {
      printf("!=\n");
      }
    ,*/
    
    return 0;
  }

#+END_SRC
*** 单链表
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;

  typedef struct node {
    datatype data;
    struct node * next;
  }listnode, *linklist;//typedef struct node * linklist;

  linklist list_create();
  linklist head_insert(linklist H, datatype value);
  void list_show(linklist H);
  linklist list_insert(linklist H, datatype value, int pos);
  linklist list_delete(linklist H, int pos);
  int list_sort(linklist H);
  int list_reverse(linklist H);

#+END_SRC
**** 实现文件
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "linklist.h"

  linklist list_create() {
      linklist H;

      if((H = (linklist)malloc(sizeof(listnode))) == NULL) {
          printf("malloc faild\n");
          return NULL;
      }
      H->next = NULL;

      return H;
  }


  int head_insert(linklist H, datatype value) {
      linklist p;

      if((p = (linklist)malloc(sizeof(listnode))) == NULL) {
          printf("malloc faild\n");
          return -1;
      }
      p->data = value;

      p->next = H->next;
      H->next = p;
    
      return 0; 
  }


  void list_show(linklist H) {
      while (H->next != NULL) {
          printf("%d ", H->next->data);
          H = H->next;
      }
      puts("");
  }

  int list_insert(linklist H, datatype value, int pos) {
      linklist p = H, q;
      int i = 0;

      if (pos < 0) {
          printf("Insert pos invald\n");
          return -1;
      }

      while (i < pos) {
          p = p->next;
          if (p == NULL) {
              printf("Insert pos invald\n");
              return -1;
          }
          i++;
      }

      if((q = (linklist)malloc(sizeof(listnode))) == NULL) {
          printf("malloc faild\n");
          return -1;
      }
      q->data = value;

      q->next = p->next;
      p->next = q;

      return 0;
  }

  int list_delete(linklist H, int pos) {
      linklist p = H, q;
      int i = 0;

      if (pos < 0) {
          printf("Delete pos invalid\n");
          return -1;
      }

      while (i < pos) {
          p = p->next;
          if (p == NULL) {
              printf("Delete pos invalid\n");
              return -1;
          }
          i++;
      }
      if (p->next == NULL) {
          printf("Delete pos invalid\n");
          return -1;
      }

      q = p->next;
      p->next = q->next;
      free(q);
      q = NULL;

      return 0;
  }

  int list_sort(linklist H){
      linklist p = H->next, q, r;
      H->next = NULL;

      while (p != NULL) {
          q = p;
          p = p->next;

          r = H;
          while (r->next != NULL && r->next->data < q->data) {
              r = r->next;
          }
          q->next = r->next;
          r->next = q;
      }
      return 0;
  }

  int list_reverse(linklist H) {
      linklist p = H->next, q;
      H->next = NULL;

      while (p != NULL) {
          q = p;
          p = p->next;
    
          q->next = H->next;
          H->next = q;
      }

      return 0;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  nclude <stdio.h>
  #include <stdlib.h>
  #include "linklist.h"

  int main(int argc, const char *argv[])
  {
    linklist H = NULL;

    H = list_create();

    head_insert(H, 10);
    head_insert(H, 80);
    head_insert(H, 20);

    list_show(H);
    list_insert(H, 30, 2);
    list_show(H);

    list_delete(H, 4);
    list_show(H);

    list_reverse(H);
    list_show(H);

    list_sort(H);
    list_show(H);

    return 0;
  }

#+END_SRC
* 第二天<2016-07-22 Fri> 
** 代码练习
*** LinkStack
**** 头文件
#+BEGIN_SRC  C
  typedef int DataType;
  typedef  void LinkStack ;
  typedef _tag_LinkStackNode LinkStackNode;
  struct _tag_LinkStackNode {
    LinkStackNode* next;
  }

  LinkStack* LinkStack_Create();

  int LinkStack_Push(LinkStack* stack,LinkListNode* node);
  void* LinkStack_Pop(LinkStack* stack);
  int LinkStack_Clear(LinkStack* stack);
  int LinkStack_Empty(LinkStack* stack);
  void* LinkStack_Top(LinkStack* stack);

#+END_SRC
**** 实现文件
#+BEGIN_SRC  C
  #include <stdio.h>
  #include <stdlib.h>
  #include "LinkStack.h"
  typedef struct _tag_LinkStack
  {

    LinkStackNode header;
    int length;
  }TLinkStack;

  LinkStack* LinkStack_Create()
  {

    TLinkStack* ret=(TLinkStack*)malloc(sizeof(TLinkStack));
    if(ret == NULL)
      {

        printf("malloc LinkStack failed");
      }else{
      ret->length=0;
      ret->header.next=NULL;

    }
    return ret;
  }

  int LinkStack_Push(LinkStack* stack,LinkListNode* node)
  {
    TLinkStack* TStack=(TLinkStack*)stack;
    int ret=(TStack != NULL) && (node != NULL);
    if(ret)
      {
        LinkStackNode* current=(LinkStackNode*)TStack;
        node->next=current->next;
        current->next=node;
        TStack->length++;
      }
    return ret;
  }

  LinkStackNode* LinkStack_Pop(LinkStack* stack)
  {

    TLinkStack* TStack=(TLinkStack*)stack;
    LinkStackNode* ret=NULL;
    if(TStack != NULL && TStack->length>0)
      {

        LinkListNode* current=(LinkListNode*)TStack;
            ret=current->next;

    
      }
  }
  void* LinkStack_Top(LinkStack* stack)
  {

    TLinkStack* TStack=(TLinkStack*)stack;
    LinkStackNode* node=(LinkStackNode*)TStack;
    void* ret=NULL;
    if(TStack !=NULL && node->next != NULL )
      {
        ret=node->next;

      }
    return ret;
  }



#+END_SRC
**** 主函数
#+BEGIN_SRC C

#+END_SRC

*** SeqQueue
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;
  #define N 5

  typedef struct {
    datatype data[N];
    int front;
    int rear;
  }sequeue;

  sequeue * queue_create();
  int queue_empty(sequeue *sq);
  int inqueue(sequeue * sq, datatype value);
  datatype dequeue(sequeue * sq);
  int queue_full(sequeue * sq);
  int queue_clear(sequeue * sq);
  typedef int datatype;
  #define N 5

#+END_SRC
**** 实现文件
#+BEGIN_SRC c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include "sequeue.h"

  sequeue * queue_create() {
    sequeue* ret=NULL;
    ret=(sequeue*)malloc(sizeof(sequeue));
    if(ret=NULL)
      {

        printf("malloc sequeue failed");
        return ret;
      }
    bzero(sq->data,sizeof(sq->data));
    ret->front=0;
    ret->rear=0;
    return ret;
  }
  int queue_empty(sequeue *sq) {

    int ret=(sq != NULL);
    if(ret)
      {

        if(sq->front==sq->rear)
          {

            return ret;
          }else{
          return 0;
        }

      }
    return ret;
  }
  int inqueue(sequeue * sq, datatype value){
    int ret=(sq != NULL) && (rear+1)%N != front;
    if(ret)
      {
        sq->node[sq->rear]=value;
        sq->rear=(sq->rear+1)/N;
   
      }
    return ret;
  }
  datatype dequeue(sequeue * sq){
    int ret=(sq != NULL)&& (sq->front != sq->rear);
    if(ret) {
      sq->ret=sq->node[sq->front];
      sq->front=(sq->front+1)%N;

      }
    return ret;
  }
  int queue_full(sequeue * sq){
    int ret=(sq != NULL);
    if(ret && (sq->rear+1)%N == sq->front)
      {
        return ret;

      }
    return ret;
  }
  int queue_clear(sequeue * sq){
    int ret=(sq != NULL)
      if(ret) {

        sq->front == sq->rear;
      }
    return ret;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "sequeue.h"

  int main(int argc, const char *argv[])
  {
    sequeue * sq;

    if ((sq = queue_create()) == NULL) {
      return 0;
    }
    
    enqueue(sq, 30);
    enqueue(sq, 60);
    enqueue(sq, 90);

    while (!queue_empty(sq)) {
      printf("%d ", dequeue(sq));
    }
    puts("");
    free(sq);
    sq=NULL;
    return 0;
  }
#+END_SRC
**** Makefile
#+BEGIN_SRC makefile
  OBJS=SeqQueue.o main.o
  CC=gcc
  CFLAGS= -g -Wall
  SeqQueue:$(OBJS)
      $(CC) $(CFLAGS) -o $@ $^
  SeqQueue.o:SeqQueue.c SeqQueue.h
      $(CC) $(CFLAGS) -o $@ $^
  main.o:main.c SeqQueue.h
      $(CC) $(CFLAGS) -o $@ $^

#+END_SRC
*** LinkQueue
**** 头文件
#+BEGIN_SRC C :main no 
  typedef int datatype;
  typedef struct node {
    datatype data;
    struct node *next;
  }listnode,*linklist;

  typedef struct {

    linklist front;
    linklist rear;
  }linkqueue;
  linkqueue*  queue_create();
  int queue_empty(linkqueue *lqueue);
  int enqueue(linkqueue *lq,datatype value);
  datatype dequeue(linkqueue *lqueue);
  int queue_clear(linkqueue *lqueue);
#+END_SRC
**** 实现文件
#+BEGIN_SRC C :main no 
  #include <stdio.h>
  #include<stdlib.h>
  #include<string.h>
  #include"LinkQueue.h"
  /*
    先在堆空间上申请表头,申请成功后初始化表头
    然后在堆空间上申请头指针和尾指针,申请成功后初始化.
    空队列头指针和尾指针都指向表头

  ,*/
  linkqueue* queue_create() {
    linklist list=(linklist)malloc(sizeof(listnode));
    linkqueue* ret=(linkqueue*)malloc(sizeof(linkqueue));

    if(list !=NULL)
      {

        list->data=0;
        list->next=NULL;
      }else
      {
        printf("malloc listnode failed");
        return NULL;
      }


    if(ret !=NULL)
      {

        ret->front=list;
        ret->rear=list;
      }else
      {
        printf("malloc linkqueue failed");
        return NULL;

      }

    return ret;
  }


  int queue_empty(linkqueue *lqueue) {

    return (lqueue !=NULL) && (lqueue->front ==lqueue->rear ? 1:0);
  }

  /*
    首先在堆空间上申请元素空间,申请成功后.
    申请成功后赋值,因为是尾插,所以指针域指向空,数据与赋值为传进来的数据
    然后把上个元素的 next 指针指向插入的元素
    最后把标识尾部的 rear 指针指向该元素
  ,*/
  int enqueue(linkqueue *lqueue,datatype value) {
    linklist node=(linklist)malloc(sizeof(listnode));
    if(node != NULL)
      {

        node->data=value;
        node->next=NULL;
        lqueue->rear->next=node;
        lqueue->rear=node;
        return 0;
      }else
      {

        printf("malloc linklist failed");
        return -1;
      }

  }
  /*
     先把表头指向的第一个元素(即要删除释放的元素)赋值给一个临时变量
     然后把 front 指向临时变量的 next(即临时变量的下一个元素),因为 front 指针是用来标识第一个元素的.  
     然后释放临时变量(tmp)的空间,把 tmp 置空

     返回的值是当前表头所值的第一个元素)(即队列的第一个元素)  
  ,*/
  datatype dequeue(linkqueue *lqueue) {

    if(lqueue != NULL)
      {
        listnode* tmp=lqueue->front;

        lqueue->front=tmp->next;
        free(tmp);
        tmp=NULL;
      }
    return (lqueue->front->data);
  }


  /*
    相当与删除所有元素,与删除的原理相同
  ,*/


  int queue_clear(linkqueue *lqueue) {

    if(lqueue !=NULL)
      {
        listnode* tmp=lqueue->front;

        while(lqueue->front != NULL)
          {
            tmp=lqueue->front;
            lqueue->front=tmp->next;
            free(tmp);
            tmp=NULL;

          }
      }
    return 0;
  }
  /*
    清空队列后,再加一步释放 front rear 指针
  ,*/
  int queue_free(linkqueue *lqueue) {
    if(lqueue !=NULL)
      {

        listnode* tmp=lqueue->front;
        while(lqueue->front != NULL)
          {
            tmp=lqueue->front;
            lqueue->front=tmp->next;
            free(tmp);
            tmp=NULL;
          }
        free(lqueue);
        lqueue=NULL;
      }
    return 0;

  }


#+END_SRC
**** 主函数
#+BEGIN_SRC C 
    #include <stdio.h>
    #include <stdlib.h>
    #include "LinkQueue.h"

    int main(int argc, const char *argv[])
    {
      linkqueue * lq;

      lq = queue_create();

      enqueue(lq, 1);
      enqueue(lq, 91);
      enqueue(lq, 7);
      enqueue(lq, 86);

      //queue_free(lq);
      //queue_clear(lq);
  
      while (!queue_empty(lq)) {
        printf("%d ", dequeue(lq));
      }
      //queue_free(lq);
      puts("");


      return 0;
    }
#+END_SRC
** 老师代码
*** 链式栈
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;

  typedef struct node{
    datatype data;
    struct node * next;
  }listnode, *linkstack;

  linkstack stack_create();
  int push(linkstack s, datatype value);
  datatype pop(linkstack s);
  int stack_free(linkstack s);
  int stack_empty(linkstack s);
  datatype top(linkstack s);

#+END_SRC
**** 实现文件
#+BEGIN_SRC  C
  #include <stdio.h>
  #include <stdlib.h>
  #include "stack.h"

  linkstack stack_create() {
    linkstack s;

    if ((s = (linkstack)malloc(sizeof(listnode))) == NULL) {
      printf("malloc faild\n");
      return NULL;
    }
    s->data = 0;
    s->next = NULL;

    return s;
  }

  int push(linkstack s, datatype value) {
    linkstack p;

    if ((p = (linkstack)malloc(sizeof(listnode))) == NULL) {
      printf("malloc faild\n");
      return -1;
    }
    p->data = value;

    p->next = s->next;
    s->next = p;
    
    return 0;
  }

  datatype pop(linkstack s) {
    linkstack p;
    datatype ret;

    p = s->next;
    s->next = p->next;

    ret = p->data;
    free(p);
    p = NULL;

    return ret;
  }

  int stack_free(linkstack s) {
    linkstack p;

    printf("free:");
    while (s != NULL) {
      p = s;
      s = s->next;
      printf("%d ", p->data);
      free(p);
      p = NULL;
    }
    puts("");

    return 0;
  }

  /*
   ,* ret:1 empty   
   ,* */
  int stack_empty(linkstack s) {
    return  (s->next == NULL);
  }

  datatype top(linkstack s) {
    return (s->next->data);
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>
  #include "stack.h"

  int main(int argc, const char *argv[])
  {
    linkstack s;

    if ((s = stack_create()) == NULL) {
      return 0;
    }

    push(s, 69);
    push(s, 39);
    push(s, 19);

    stack_free(s);

  #if 0
    if (!stack_empty(s) ) {
      printf("top:%d\n", top(s));
    }

    while (!stack_empty(s)) {
      printf("%d \n", pop(s) );
    }
  #endif

    return 0;
  }

#+END_SRC
*** 线性队列
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;
  #define N 100

  typedef struct {
    datatype data[N];
    int front;
    int rear;
  }sequeue;

  sequeue * queue_create();
  int queue_empty(sequeue *sq);
  int enqueue(sequeue * sq, datatype value);
  datatype dequeue(sequeue * sq);
  int queue_full(sequeue * sq);
  int queue_clear(sequeue * sq);

#+END_SRC
**** 实现文件
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include <strings.h>
  #include "sequeue.h"

  sequeue * queue_create() {
    sequeue * sq;

    if ((sq = (sequeue *)malloc(sizeof(sequeue))) == NULL) {
      printf("malloc\n");
      return NULL;
    }
    bzero(sq->data, sizeof(sq->data));
    sq->front = sq->rear = 0;
    return sq;
  }

  int queue_empty(sequeue *sq){
    if (sq->front == sq->rear) {
      return 1;
    }
    else {
      return 0;
    }
  }

  int enqueue(sequeue * sq, datatype value){
    if ((sq->rear+1) % N == sq->front) {
      printf("full\n");
      return -1;
    }
    sq->data[sq->rear] = value;
    sq->rear = (sq->rear + 1) % N;

    return 0;
  }

  datatype dequeue(sequeue * sq){
    datatype ret;

    ret = sq->data[sq->front];

    sq->front = (sq->front+1) % N;

    return ret;
  }


  int queue_full(sequeue * sq){
    if ((sq->rear+1) % N == sq->front) {
      return 1;
    }
    else {
      return 0;
    }
  }

  int queue_clear(sequeue * sq){
    bzero(sq->data, sizeof(sq->data));
    sq->front = sq->rear;

    return 0;
  }

#+END_SRC
**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "sequeue.h"

  int main(int argc, const char *argv[])
  {
    sequeue * sq;

    if ((sq = queue_create()) == NULL) {
      return 0;
    }
    
    enqueue(sq, 30);
    enqueue(sq, 60);
    enqueue(sq, 90);
    enqueue(sq, 120);
    enqueue(sq, 150);

    while (!queue_empty(sq)) {
      printf("%d ", dequeue(sq));
    }
    puts("");


    free(sq);
    sq = NULL;

    return 0;
  }

#+END_SRC
*** 链式队列
**** 头文件
#+BEGIN_SRC C
  typedef int datatype;

  typedef struct node {
    datatype data;
    struct node * next;
  }listnode, * linklist;

  typedef struct {
    linklist front;//listnode * front;  //struct node * front;
    linklist rear;
  }linkqueue;

  linkqueue * queue_create();
  int queue_empty(linkqueue * lq);
  int enqueue(linkqueue *lq, datatype value);
  datatype dequeue(linkqueue *lq);
  int queue_clear(linkqueue *lq);
  int queue_free(linkqueue *lq);

#+END_SRC
**** 实现文件
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "linkqueue.h"

  linkqueue * queue_create() {
      linklist p;
      linkqueue * lq;

      if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
          return NULL;
      }
      p->data = 0;
      p->next = NULL;

      if ((lq = (linkqueue*)malloc(sizeof(linkqueue))) == NULL) {
          return NULL;
      }
      lq->front = p;
      lq->rear = p;

      printf("%p\n", lq);
      return lq;
  }

  int queue_empty(linkqueue * lq) {
      return (lq->front->next == NULL);
      //return (lq->front == lq->rear);
  }

  int enqueue(linkqueue *lq, datatype value) {
      linklist p;

      if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
          return -1;
      }
      p->data = value;
      p->next=NULL;
      lq->rear->next = p;
      lq->rear = p;

      return 0;
  }

  datatype dequeue(linkqueue *lq) {
      linklist p;
      p  = lq->front;
      lq->front = p->next;
      free(p);
      p = NULL;

      return (lq->front->data);
  }

  int queue_clear(linkqueue *lq) {
      linklist p;

      printf("clear:");
      while (lq->front->next != NULL) {
          p = lq->front;
          lq->front = p->next;
          printf("%d ", p->data);
          free(p);
      }

      return 0;
  }

  int queue_free(linkqueue *lq) {
      linklist p;

      p = lq->front;

      printf("free:");
      while (p != NULL) {
          lq->front = p->next;
          printf("%d ", p->data);
          free(p);
          p = lq->front;
      }
      puts("");

      printf("%p\n", lq);
      free(lq);

      return 0;
  }

#+END_SRC

**** 主函数
#+BEGIN_SRC C
  #include <stdio.h>
  #include <stdlib.h>
  #include "linkqueue.h"

  int main(int argc, const char *argv[])
  {
    linkqueue * lq;

    lq = queue_create();

    enqueue(lq, 1);
    enqueue(lq, 91);
    enqueue(lq, 7);
    enqueue(lq, 86);

    queue_free(lq);
    //queue_clear(lq);
  #if 0
    while (!queue_empty(lq)) {
      printf("%d ", dequeue(lq));
    }
  #endif

    puts("");


    return 0;
  }

#+END_SRC
