一 进程 和 程序 

1.程序:一个文件，这个文件中存放的是机器码 

2.进程:一个程序一次执行过程，在这个执行过程中伴随资源的分配和释放

资源 (内存，时间片，CPU资源)

3.Linux 对进程描述 

struct task_struct{
	1.pid  //进程号
	2.ppid //父进程号 
	3.一组寄存器值(pc寄存器:告诉cpu需要执行的指令所在内存中的地址)
	4.进程状态 
	  运行态(R),可中断等待态(S),不可中断等待态(D),停止态(T),僵尸态(Z)

	....
}


二 Linux 进程管理命令 

1.查看系统进程
  ps  -ef 

  例如:
  ps -ef | grep 进程名 
  ps -ef | grep 进程号 

2.查看系统进程状态 
  ps aux  

  例如:
  ps aux | grep 进程名 
  ps aux | grep 进程号 

3.信号 
  <1>kill -l 
     显示系统中支持的信号

  <2>发一个信号给指定PID进程
  	 kill -信号编号  PID 

	 例如:
	 发送SIGSTOP信号
	 kill -19  PID  或 kill -SIGSTOP PID 

  <3>发一个信号给指定进程名的进程
	 killall -信号编号  进程名 

4.动态查看进程的信息
  top 

5.指定的进程的优先级
  在Linux 中通过nice值来影响进程的优先级，nice值越小进程的优先级越高
  nice值范围: [-20,19]

  (1)运行程序的时候，指定进程的nice值 

  nice -nice值  执行的程序 

  例如:
  nice   -1  ./while  -> nice值为 1 
  nice  --1  ./while  -> nice值为-1

  (2)修改系统中进程的nice值 
   renice  nice值  PID 

   例如:
   renice  10   8123  -> 修改成nice值为  10 
   renice  -10  8213  -> 修改成nice值为 -10

三 Linux 子进程创建 

-------------------------------------------------------------------------------------
tags : 一个索引文件，根据索引文件可以找的符号所在文件定义

生成tags文件  ctags -R  --->递归当前目录所有文件，生成tags文件 

如何使用呢?
vi -t  符号(函数名，结构体名，宏，typedef之后的名字) 
此时vi编辑器会从当前目录寻找tags文件，来定位符号所在的文件

将光标停在要查看的单词上，然后跳转: 
ctrl + ]

返回 
ctrl + t
----------------------------------------------------------------------------------------

pid_t fork(void)
功能:复制父进程来创建子进程
返回值:
成功给父进程返回子进程PID,给子进程返回0,失败返回-1 

问题:fork函数返回值不可能是什么?
回答:大于0(不可能父进程PID，不可能是1) ,小于0 ,等于 0

僵尸态子进程:子进程已经结束，但是父进程没有对其进行收尸处理 
孤儿进程    :父进程先于子进程结束，子进程变成孤儿进程，孤儿进程自动被init进程收养

练习:一个父进程创建两个子进程,子进程1睡眠10秒然后退出，子进程2一直死循环，父进程创建完两个子进程后
一直死循环，然后通过ps aux 查看这些进程的状态 

--------------------------------------------------------------------------------------------------
注意:
(1)创建子进程后,父子进程都是从fork()下一条语句执行
(2)创建子进程后,父子进程调度顺序不确定
(3)创建子进程后，父子进程的地址空间是独立的，父子进程修改的数据，不会相互影响
--------------------------------------------------------------------------------------------------

练习:
让父进程读取用户从键盘上输入的数据，然后就读取的数据写入到log.txt文件中，子进程从log.txt 
读取数据，然后输出。如果用户输入的是"quit",则父子进程结束。

要求:文件在fork之前打开,使用文件IO API操作文件


四 僵尸态子进程处理 

特点:子进程结束，父进程没有进行收尸处理，此时拥有PID号和它死亡的状态，其他的资源都已经释放。

如果僵尸态子进程很多，就会导致PID不够分配，最终无法创建子进程。所以，必须对僵尸态子进程进行收尸处理，来
释放它未释放的资源。

1.pid_t wait(int *status);
功能:等待子进程变成僵尸态，然后对僵尸态子进程进行收尸处理
参数:
@status 获取子进程结束时状态(通过这个状态，可以分析子进程死亡的原因)
返回值:
成功返回僵尸子进程的pid ,失败返回-1(没有子进程)

注意:它会使调用者阻塞,直到出现僵尸态子进程 

2.pid_t waitpid(pid_t pid, int *status, int options);
参数:
@pid  子进程pid (只等待这个子进程，其他子进程不管) , -1 (任意子进程) 
@status 获取子进程结束时状态 
@options 0:阻塞方式调用(傻等)  WNOHANG:非阻塞方式调用(如果没有僵尸子进程立即返回)
返回值:
成功返回僵尸子进程的pid,如果是非阻塞方式调用，且没有子进程结束，此时返回0,如果没有子进程，调用失败返回-1


思考:等价于wait函数的waitpid 
回答:waitpid(-1,&status,0);

