一 标准输入 标准输出 标准出错 

标准输入  文件描述符:0     流指针:stdin
标准输出  文件描述符:1     流指针:stdout
标准出错  文件描述符:2     流指针:stderr

二 缓存类型

(1)全缓存
   <1>缓存满
   <2>fflush刷新
   <3>程序正常退出

(2)行缓存
   <0>遇到换行符就刷新
   <1>缓存满
   <2>fflush刷新
   <3>程序正常退出

(3)不缓存
	直接输出

设计原则:
<1>默认都是全缓存，除非流和终端设备关联，此时是行缓存
<2>标准输入和标准输出和终端设备关联，他们是行缓存
<3>标准出错是不缓存

三 标准IO读写函数

1.单个字符的读写

int fgetc(FILE *stream);
功能:
从一个指定的流中读取一个字符
返回值:
成功返回读取的字符，失败返回-1


int fputc(int c, FILE *stream);
功能:将一个字符写入一个指定的流
返回值:
成功返回写入的字符，失败返回-1

练习:
实现一个文件拷贝的功能


2.多个字符的读写(字符串读写)

char *fgets(char *s, int size, FILE *stream);
功能:每次做多从stream流中读取size - 1个字符存放在s指向的地址中
参数:
@s      存放数据的地址
@size   期望读取的大小
@stream 打开的文件
返回：
成功返回s,失败返回NULL 或者读到文件尾部返回NULL 

特点:
(1)每次最多读取size - 1个字符存放
(2)每次读取的时候，遇到'\n'字符或已经读取了size - 1个字符 或者读到文件尾部会停止
(3)每次读取结束的时候，一定会加上'\0'字符 

练习:
从标准输入读取数据，然后输出，如果用户直接输入的是回车键则程序运行结束
要求:存储用户输入的数据的时候，不要将用户输入的回车键进行存储


int fputs(const char *s, FILE *stream)
功能:
将一个字符串，输出(写)到指定的流,写的时候不包括'\0'字符(即:将'\0'之前的字符写入到指定的流中) 
返回值:
成功返回非负的整数，失败返回-1

练习:
实现文件拷贝,要求 分别拷贝 文本文件和二进制文件，查看拷贝的效果

3.二进制文件读写

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

实际读取的数据个数 fread(数据存放的地址，数据的大小，期望读取的数据个数，流指针)

数据:
可以int ,char ,float ,double ...., 也可以是一个结构体，

size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);

实际写入的数据个数 fwrite(数据存放的地址，数据的大小，要求写入的数据个数，流指针)

练习:
实现文件拷贝 

char buf[1024];
n = fread(buf,1,1024,fp_src);

4.文件定位

int fseek(FILE *stream, long offset, int whence);
参数:
@stream   流指针 
@offset   大于0的数表示向后偏移，小于0的数表示向前偏移
@whence   SEEK_SET,SEEK_CUR,SEEK_END
返回值:
成功返回0,失败返回-1

long ftell(FILE *stream);
功能:返回当前文件的偏移量

void rewind(FILE *stream);
功能:定位到文件开始位置

rewind(fp) <=> fseek(fp,0,SEEK_SET);

问题:如何获取文件大小?
回答:
fseek(fp,0,SEEK_END);
len = ftell(fp);

练习:
将结构体的数据写入文件，然后读取出来给另外一个结构体变量，最后输出这个变量的值

struct student{
	char name[15];
	int  age;
	float score;
};

struct student stu1 = {"xiaoming",10,50}; //写入文件中存放
struct student stu2;
从文件中读取学生的信息给stu2，然后输出stu2 

四 Linux 下库的制作与使用

静态库:程序在编译的时候，如果链接的是静态库，会把程序中需要调用的函数接口实现代码从静态库中拷贝到
可执行程序文件中，生成的可执行文件体积大，程序在运行的时候，不需要库的支持

动态库:程序在编译的时候，如果链接的是动态库，此时在可执行文件的头信息中记录动态库的名字，在程序
运行的时候，操作系统会读取可执行文件的头信息，从而知道可执行文件在运行的时候，需要加载那些动态库,

注意:动态连接的时候，生成可执行文件体积小，但是程序在运行的时候，需要加载动态库

1.Linux 库的格式 
  静态库  libname.a 
  动态库  libname.so 

  问题:如libjpeg.so 这个库的名字是什么?
  回答:库的名字jpeg 
 
2.gcc 编译器的参数
  -I (指定头文件路径)  指定编译器搜索头文件路径的路径，默认在/usr/include 目录下搜索
  -L (指定库的路径) 指定编译器在链接库的时候，搜索的路径，默认在/usr/lib 和 /lib搜索 
  -l (指定库的名字)指定编译器链接时候，库的名字

  注意:
  默认情况gcc只能识别它自带的库，无法识别第三方库(不是gcc携带的)


3.静态库
  <1>将 xxx.c 编译成 xxx.o
  	 gcc -c xxx.c -o xxx.o 
  <2>将xxx.o打包生成静态库
  	 ar -cr  libxxx.a  *.o
	
  <3>使用 
  	 gcc  xxx.c -L 库的路径  -l库的名字 


4.动态库 	
  <1>将 xxx.c 编译成 xxx.o
  	 gcc -c xxx.c -o xxx.o 
  <2>将xxx.o打包生成动态库 
    gcc  -shared *.o  -o libdll.so

  <3>查看可执行文件依赖的动态库
  	readelf -a  xxx | grep "Shared"
	
  <4>使用 
  	[1]编译时(编译器) 
	   gcc  xxx.c -L 库的路径  -l库的名字 
		
	[2]运行时(操作系统) 
	   操作系统在运行可执行文件的时候，会读取可执行文件的头信息，然后加载头信息中记录的动态库
	   操作系统默认加载动态库搜索路径
	   <1>在LD_LIBRARY_PATH环境变量中包含的路径搜索
	   <2>在/usr/lib 和 /lib目录下搜索 

	   将自己的动态库所在的路径添加到环境变量中
	   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库的路径 

	   将它写入用户主目录下.bashrc或者/etc/bash.bashrc中可以永久有效 
----------------------------------------------------------------------------------------------------------
问题:如果动态和静态库同时在一个目录下存在，编译器默认链接的时候，是什么库呢?
回答:默认链接的是动态库，如果需要链接静态库，此时需要加上 -static 参数 

问题:如果库的名字有版本号，编译如何识别呢?
回答:此时需要建立一个软连接 连接到库，但是软连接文件的名称要符合库的命名规则(libxxx.a ,libxxx.so )

----------------------------------------------------------------------------------------------------------
