* 第一天<2016-07-28 Th>
** 基本概念

1.库 : 一组实现好的函数接口

2.系统调用:操作系统给用户空间提供的一组函数接口,我们可以通过这一组函数接口进入内核空间，从而使用
内核提供的服务

3.在Linux中，我们可以通过open系统调用打开一个文件，可以获得一个文件描述符(fd),这个fd表示打开的文件
 ,我们可以read系统调用来读文件，可以通过write系统调用来写文件，通过close系统调用关闭文件

** 文件相关系统调用函数
*** 打开文件

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
@pathname  文件的路径 例如:"/home/linux/hello.c"
@flags ：打开文件的方式

O_RDONLY  只读
O_WRONLY  只写
O_RDWR    读写
O_CREAT   不存在则创建
O_APPEND  追加
O_TRUNC   存在则清空

注意:
(1)这些标示可以用"|"运算符连接在一起使用
(2)如果使用了O_CREAT参数，需要指定创建文件的权限

@mode 用来指定文件创建时的权限
注意:新建文件的实际权限 mode & ~umask

返回值:
成功返回文件描述符，失败返回-1

--------------------------------------------------------------
程序运行的时候，操作系统默认打开了标准输入，标准输出，标准出错
标准输入:0
标准输出:1
标准出错:2

文件描述符分配原则:最小未使用
-------------------------------------------------------------

练习:
以读写方式打开一个文件，如果文件不存在则创建，如果文件存在则清空，程序运行结束的时候
观察新创建文件权限是多少

*** 读文件

int read(int fd, void *buf, size_t count);
参数:
@fd  打开的文件
@buf 存放数据的地址
@count 期望读取字节数
返回值:
成功实际读取的字节数，失败返回-1,读到文件尾部返回0

*** 写文件

int write(int fd, void *buf, size_t count);
参数:
@fd  打开的文件
@buf 存放数据的地址
@count 需要写入的字节数
返回值:
成功实际写入的字节数，失败返回-1

练习:实现文件拷贝

./a.out srcfile destfile

(1)打开源文件  : O_RDONLY
(2)打开目标文件: O_WRONLY | O_CREAT |O_TRUNC

(3)实现思路
   从源文件中读取数据存放在buf中，然后将buf中的数据写入目标文件

*** 文件定位
int  lseek(int fd, off_t offset, int whence);
功能:更改内核空间打开文件的offset值
参数:
@fd       打开的文件
@offset   偏移量     大于0的数->向后偏移  小于0的数->向前偏移
@whence   SEEK_SET:文件头开始   SEEK_CUR:从当前位置开始  SEEK_END:从文件尾部开始
返回值:
成功返回更新之后的offset值，失败返回-1

思考:如何文件的大小？
回答:lseek(fd,0,SEEK_END) -> 文件大小
问题:此时如果接着读文件，读取的内容是什么?
回答:此时读文件read函数返回0,表示没有数据可读

** 标准IO (C标准库提供的文件的操作函数接口)

特点:
(1)在系统调用做了一层封装，向上层提供统一的接口，屏蔽操作系统之间的差异,便于代码的移植
(2)对文件操作有缓存，读写的时候，数据先存放在缓存中，减少系统调用的次数，提高读写的效率

** 打开文件
FILE *fopen(const char *path, const char *mode);
参数:
@path   文件路径名
@mode

"r"  只读方式    ----> O_RDONLY
"r+" 读写方式    ----> O_RDWR
"w"  只写方式，如果文件不存在，则创建，文件存则清空，->O_WRONLY | O_CREAT |O_TRUNC,0666
"w+" 读写方式，如果文件不存在，则创建，文件存则清空，->O_RDWR | O_CREAT |O_TRUNC,0666
"a"  只写方式，文件尾部开始写，如果文件不存在则创建  ->O_WRONLY | O_APPEND | O_CREAT,0666
"a+" 读写方式，第一次读的时候，从文件开始读，写总是在末尾写，如果文件不存在则创建 ->O_RDWR | O_APPEND | O_CREAT,0666

返回值:
成功会返回文件流指针(标示的打开文件)，失败返回NULL

** 读写操作

(1)格式串写(格式化输出)
int printf(const char *format, ...);->格式化输出的对象：标准输出
int fprintf(FILE *stream, const char *format,...);->格式化输出的对象：一个打开的文件
int sprintf(char *str, const char *format, ...);->格式化输出的对象:内存的一块区域

练习:
以读写方式打开一个文件，文件不存在则创建，文件存在则清空,然后向文件中写入一个整数和字符串，格式如下:
字符串长度:字符串内容  例如 5:hello

要求:
需要将这种格式的数据先存放在数组buf中，然后输出，接着将buf的数据写入文件

* 第二天<2016-07-29 Fri>
